#line 1 "..\\..\\Library\\StdDriver\\src\\wwdt.c"
 





 
#line 1 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\NuMicro.h"
 





 



#line 1 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
 







 






































 







 
 
 



 



 
typedef enum IRQn
{
     
    NonMaskableInt_IRQn           = -14,       
    MemoryManagement_IRQn         = -12,       
    BusFault_IRQn                 = -11,       
    UsageFault_IRQn               = -10,       
    SVCall_IRQn                   = -5,        
    DebugMonitor_IRQn             = -4,        
    PendSV_IRQn                   = -2,        
    SysTick_IRQn                  = -1,        

     

    LVD_IRQn                      = 0,
    PWRWU_IRQn                    = 2,
    HWSEM0_IRQn                   = 3,
    CKFAIL_IRQn                   = 4,
    WHC0_IRQn                     = 5,
    RTC_IRQn                      = 6,
    TAMPER_IRQn                   = 7,
    WDT2_IRQn                     = 8,
    WWDT2_IRQn                    = 9,
    EINT0_IRQn                    = 10,
    EINT1_IRQn                    = 11,
    EINT2_IRQn                    = 12,
    EINT3_IRQn                    = 13,
    GPA_IRQn                      = 16,
    GPB_IRQn                      = 17,
    GPC_IRQn                      = 18,
    GPD_IRQn                      = 19,
    TMR2_IRQn                     = 22,
    TMR3_IRQn                     = 23,
    BRAKE0_IRQn                   = 24,
    EPWM0P0_IRQn                  = 25,
    EPWM0P1_IRQn                  = 26,
    EPWM0P2_IRQn                  = 27,
    QEI0_IRQn                     = 28,
    ECAP0_IRQn                    = 29,
    QSPI1_IRQn                    = 31,
    UART1_IRQn                    = 35,
    UART2_IRQn                    = 36,
    UART3_IRQn                    = 37,
    UART4_IRQn                    = 38,
    UART5_IRQn                    = 39,
    EADC00_IRQn                   = 40,
    EADC01_IRQn                   = 41,
    EADC02_IRQn                   = 42,
    EADC03_IRQn                   = 43,
    I2C1_IRQn                     = 45,
    I2S0_IRQn                     = 46,
    CANFD00_IRQn                  = 47,
    SC0_IRQn                      = 48,
    GPE_IRQn                      = 49,
    GPF_IRQn                      = 50,
    GPG_IRQn                      = 51,
    GPH_IRQn                      = 52,
    GPI_IRQn                      = 53,
    GPJ_IRQn                      = 54,
    TMR4_IRQn                     = 55,
    TMR5_IRQn                     = 56,
    TMR6_IRQn                     = 57,
    TMR7_IRQn                     = 58,
    BRAKE1_IRQn                   = 59,
    EPWM1P0_IRQn                  = 60,
    EPWM1P1_IRQn                  = 61,
    EPWM1P2_IRQn                  = 62,
    QEI1_IRQn                     = 63,
    ECAP1_IRQn                    = 64,
    SPI0_IRQn                     = 65,
    SPI1_IRQn                     = 66,
    PDMA2_IRQn                    = 67,
    PDMA3_IRQn                    = 68,
    UART6_IRQn                    = 69,
    UART7_IRQn                    = 70,
    UART8_IRQn                    = 71,
    UART9_IRQn                    = 72,
    UART10_IRQn                   = 73,
    UART11_IRQn                   = 74,
    I2C2_IRQn                     = 75,
    I2C3_IRQn                     = 76,
    I2S1_IRQn                     = 77,
    CANFD10_IRQn                  = 78,
    SC1_IRQn                      = 79,
    GPK_IRQn                      = 80,
    GPL_IRQn                      = 81,
    GPM_IRQn                      = 82,
    GPN_IRQn                      = 83,
    TMR8_IRQn                     = 84,
    TMR9_IRQn                     = 85,
    TMR10_IRQn                    = 86,
    TMR11_IRQn                    = 87,
    BRAKE2_IRQn                   = 88,
    EPWM2P0_IRQn                  = 89,
    EPWM2P1_IRQn                  = 90,
    EPWM2P2_IRQn                  = 91,
    QEI2_IRQn                     = 92,
    ECAP2_IRQn                    = 93,
    SPI2_IRQn                     = 94,
    SPI3_IRQn                     = 95,
    UART12_IRQn                   = 96,
    UART13_IRQn                   = 97,
    UART14_IRQn                   = 98,
    UART15_IRQn                   = 99,
    UART16_IRQn                   = 100,
    I2C4_IRQn                     = 101,
    I2C5_IRQn                     = 102,
    CANFD20_IRQn                  = 103,
    CANFD30_IRQn                  = 104,
    KPI_IRQn                      = 105,
    CANFD01_IRQn                  = 106,
    CANFD11_IRQn                  = 107,
    CANFD21_IRQn                  = 108,
    CANFD31_IRQn                  = 109,
    ADC0_IRQn                     = 110,
}
IRQn_Type;






 

 
#line 203 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"

   


#line 1 "..\\..\\Library\\CMSIS\\Include\\core_cm4.h"
 




 

























 











#line 1 "E:\\Keil_v5\\ARM\\ARM_Compiler_5.06u7\\Bin\\..\\include\\stdint.h"
 
 





 









     
#line 27 "E:\\Keil_v5\\ARM\\ARM_Compiler_5.06u7\\Bin\\..\\include\\stdint.h"
     











#line 46 "E:\\Keil_v5\\ARM\\ARM_Compiler_5.06u7\\Bin\\..\\include\\stdint.h"





 

     

     
typedef   signed          char int8_t;
typedef   signed short     int int16_t;
typedef   signed           int int32_t;
typedef   signed       __int64 int64_t;

     
typedef unsigned          char uint8_t;
typedef unsigned short     int uint16_t;
typedef unsigned           int uint32_t;
typedef unsigned       __int64 uint64_t;

     

     
     
typedef   signed          char int_least8_t;
typedef   signed short     int int_least16_t;
typedef   signed           int int_least32_t;
typedef   signed       __int64 int_least64_t;

     
typedef unsigned          char uint_least8_t;
typedef unsigned short     int uint_least16_t;
typedef unsigned           int uint_least32_t;
typedef unsigned       __int64 uint_least64_t;

     

     
typedef   signed           int int_fast8_t;
typedef   signed           int int_fast16_t;
typedef   signed           int int_fast32_t;
typedef   signed       __int64 int_fast64_t;

     
typedef unsigned           int uint_fast8_t;
typedef unsigned           int uint_fast16_t;
typedef unsigned           int uint_fast32_t;
typedef unsigned       __int64 uint_fast64_t;

     




typedef   signed           int intptr_t;
typedef unsigned           int uintptr_t;


     
typedef   signed     long long intmax_t;
typedef unsigned     long long uintmax_t;




     

     





     





     





     

     





     





     





     

     





     





     





     

     






     






     






     

     


     


     


     

     
#line 216 "E:\\Keil_v5\\ARM\\ARM_Compiler_5.06u7\\Bin\\..\\include\\stdint.h"

     



     






     
    
 



#line 241 "E:\\Keil_v5\\ARM\\ARM_Compiler_5.06u7\\Bin\\..\\include\\stdint.h"

     







     










     











#line 305 "E:\\Keil_v5\\ARM\\ARM_Compiler_5.06u7\\Bin\\..\\include\\stdint.h"






 
#line 45 "..\\..\\Library\\CMSIS\\Include\\core_cm4.h"

















 




 



 

 













#line 120 "..\\..\\Library\\CMSIS\\Include\\core_cm4.h"



 
#line 135 "..\\..\\Library\\CMSIS\\Include\\core_cm4.h"

#line 209 "..\\..\\Library\\CMSIS\\Include\\core_cm4.h"

#line 1 "..\\..\\Library\\CMSIS\\Include\\core_cmInstr.h"
 




 

























 












 



 

 
#line 1 "..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"
 




 

























 










 



 

 
 





 
static __inline uint32_t __get_CONTROL(void)
{
  register uint32_t __regControl         __asm("control");
  return(__regControl);
}






 
static __inline void __set_CONTROL(uint32_t control)
{
  register uint32_t __regControl         __asm("control");
  __regControl = control;
}






 
static __inline uint32_t __get_IPSR(void)
{
  register uint32_t __regIPSR          __asm("ipsr");
  return(__regIPSR);
}






 
static __inline uint32_t __get_APSR(void)
{
  register uint32_t __regAPSR          __asm("apsr");
  return(__regAPSR);
}






 
static __inline uint32_t __get_xPSR(void)
{
  register uint32_t __regXPSR          __asm("xpsr");
  return(__regXPSR);
}






 
static __inline uint32_t __get_PSP(void)
{
  register uint32_t __regProcessStackPointer  __asm("psp");
  return(__regProcessStackPointer);
}






 
static __inline void __set_PSP(uint32_t topOfProcStack)
{
  register uint32_t __regProcessStackPointer  __asm("psp");
  __regProcessStackPointer = topOfProcStack;
}






 
static __inline uint32_t __get_MSP(void)
{
  register uint32_t __regMainStackPointer     __asm("msp");
  return(__regMainStackPointer);
}






 
static __inline void __set_MSP(uint32_t topOfMainStack)
{
  register uint32_t __regMainStackPointer     __asm("msp");
  __regMainStackPointer = topOfMainStack;
}






 
static __inline uint32_t __get_PRIMASK(void)
{
  register uint32_t __regPriMask         __asm("primask");
  return(__regPriMask);
}






 
static __inline void __set_PRIMASK(uint32_t priMask)
{
  register uint32_t __regPriMask         __asm("primask");
  __regPriMask = (priMask);
}








 







 







 
static __inline uint32_t  __get_BASEPRI(void)
{
  register uint32_t __regBasePri         __asm("basepri");
  return(__regBasePri);
}






 
static __inline void __set_BASEPRI(uint32_t basePri)
{
  register uint32_t __regBasePri         __asm("basepri");
  __regBasePri = (basePri & 0xFFU);
}







 
static __inline void __set_BASEPRI_MAX(uint32_t basePri)
{
  register uint32_t __regBasePriMax      __asm("basepri_max");
  __regBasePriMax = (basePri & 0xFFU);
}






 
static __inline uint32_t __get_FAULTMASK(void)
{
  register uint32_t __regFaultMask       __asm("faultmask");
  return(__regFaultMask);
}






 
static __inline void __set_FAULTMASK(uint32_t faultMask)
{
  register uint32_t __regFaultMask       __asm("faultmask");
  __regFaultMask = (faultMask & (uint32_t)1);
}










 
static __inline uint32_t __get_FPSCR(void)
{

  register uint32_t __regfpscr         __asm("fpscr");
  return(__regfpscr);



}






 
static __inline void __set_FPSCR(uint32_t fpscr)
{

  register uint32_t __regfpscr         __asm("fpscr");
  __regfpscr = (fpscr);

}





 


 



 




 






 







 






 








 










 










 











 








 

__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
{
  rev16 r0, r0
  bx lr
}







 

__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
{
  revsh r0, r0
  bx lr
}









 









 








 
#line 455 "..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"







 










 












 












 














 














 














 










 









 









 









 

__attribute__((section(".rrx_text"))) static __inline __asm uint32_t __RRX(uint32_t value)
{
  rrx r0, r0
  bx lr
}








 








 








 








 








 








 




   


 



 



#line 720 "..\\..\\Library\\CMSIS\\Include\\cmsis_armcc.h"











 


#line 54 "..\\..\\Library\\CMSIS\\Include\\core_cmInstr.h"

 
#line 84 "..\\..\\Library\\CMSIS\\Include\\core_cmInstr.h"

   

#line 211 "..\\..\\Library\\CMSIS\\Include\\core_cm4.h"
#line 1 "..\\..\\Library\\CMSIS\\Include\\core_cmFunc.h"
 




 

























 












 



 

 
#line 54 "..\\..\\Library\\CMSIS\\Include\\core_cmFunc.h"

 
#line 84 "..\\..\\Library\\CMSIS\\Include\\core_cmFunc.h"

 

#line 212 "..\\..\\Library\\CMSIS\\Include\\core_cm4.h"
#line 1 "..\\..\\Library\\CMSIS\\Include\\core_cmSimd.h"
 




 

























 
















 



 

 
#line 58 "..\\..\\Library\\CMSIS\\Include\\core_cmSimd.h"

 
#line 88 "..\\..\\Library\\CMSIS\\Include\\core_cmSimd.h"

 






#line 213 "..\\..\\Library\\CMSIS\\Include\\core_cm4.h"
















 
#line 256 "..\\..\\Library\\CMSIS\\Include\\core_cm4.h"

 






 
#line 272 "..\\..\\Library\\CMSIS\\Include\\core_cm4.h"

 




 













 



 






 



 
typedef union
{
  struct
  {
    uint32_t _reserved0:16;               
    uint32_t GE:4;                        
    uint32_t _reserved1:7;                
    uint32_t Q:1;                         
    uint32_t V:1;                         
    uint32_t C:1;                         
    uint32_t Z:1;                         
    uint32_t N:1;                         
  } b;                                    
  uint32_t w;                             
} APSR_Type;

 





















 
typedef union
{
  struct
  {
    uint32_t ISR:9;                       
    uint32_t _reserved0:23;               
  } b;                                    
  uint32_t w;                             
} IPSR_Type;

 






 
typedef union
{
  struct
  {
    uint32_t ISR:9;                       
    uint32_t _reserved0:7;                
    uint32_t GE:4;                        
    uint32_t _reserved1:4;                
    uint32_t T:1;                         
    uint32_t IT:2;                        
    uint32_t Q:1;                         
    uint32_t V:1;                         
    uint32_t C:1;                         
    uint32_t Z:1;                         
    uint32_t N:1;                         
  } b;                                    
  uint32_t w;                             
} xPSR_Type;

 






























 
typedef union
{
  struct
  {
    uint32_t nPRIV:1;                     
    uint32_t SPSEL:1;                     
    uint32_t FPCA:1;                      
    uint32_t _reserved0:29;               
  } b;                                    
  uint32_t w;                             
} CONTROL_Type;

 









 







 



 
typedef struct
{
  volatile uint32_t ISER[8U];                
        uint32_t RESERVED0[24U];
  volatile uint32_t ICER[8U];                
        uint32_t RSERVED1[24U];
  volatile uint32_t ISPR[8U];                
        uint32_t RESERVED2[24U];
  volatile uint32_t ICPR[8U];                
        uint32_t RESERVED3[24U];
  volatile uint32_t IABR[8U];                
        uint32_t RESERVED4[56U];
  volatile uint8_t  IP[240U];                
        uint32_t RESERVED5[644U];
  volatile  uint32_t STIR;                    
}  NVIC_Type;

 



 







 



 
typedef struct
{
  volatile const  uint32_t CPUID;                   
  volatile uint32_t ICSR;                    
  volatile uint32_t VTOR;                    
  volatile uint32_t AIRCR;                   
  volatile uint32_t SCR;                     
  volatile uint32_t CCR;                     
  volatile uint8_t  SHP[12U];                
  volatile uint32_t SHCSR;                   
  volatile uint32_t CFSR;                    
  volatile uint32_t HFSR;                    
  volatile uint32_t DFSR;                    
  volatile uint32_t MMFAR;                   
  volatile uint32_t BFAR;                    
  volatile uint32_t AFSR;                    
  volatile const  uint32_t PFR[2U];                 
  volatile const  uint32_t DFR;                     
  volatile const  uint32_t ADR;                     
  volatile const  uint32_t MMFR[4U];                
  volatile const  uint32_t ISAR[5U];                
        uint32_t RESERVED0[5U];
  volatile uint32_t CPACR;                   
} SCB_Type;

 















 






























 



 





















 









 


















 










































 









 









 















 







 



 
typedef struct
{
        uint32_t RESERVED0[1U];
  volatile const  uint32_t ICTR;                    
  volatile uint32_t ACTLR;                   
} SCnSCB_Type;

 



 















 







 



 
typedef struct
{
  volatile uint32_t CTRL;                    
  volatile uint32_t LOAD;                    
  volatile uint32_t VAL;                     
  volatile const  uint32_t CALIB;                   
} SysTick_Type;

 












 



 



 









 







 



 
typedef struct
{
  volatile  union
  {
    volatile  uint8_t    u8;                  
    volatile  uint16_t   u16;                 
    volatile  uint32_t   u32;                 
  }  PORT [32U];                          
        uint32_t RESERVED0[864U];
  volatile uint32_t TER;                     
        uint32_t RESERVED1[15U];
  volatile uint32_t TPR;                     
        uint32_t RESERVED2[15U];
  volatile uint32_t TCR;                     
        uint32_t RESERVED3[29U];
  volatile  uint32_t IWR;                     
  volatile const  uint32_t IRR;                     
  volatile uint32_t IMCR;                    
        uint32_t RESERVED4[43U];
  volatile  uint32_t LAR;                     
  volatile const  uint32_t LSR;                     
        uint32_t RESERVED5[6U];
  volatile const  uint32_t PID4;                    
  volatile const  uint32_t PID5;                    
  volatile const  uint32_t PID6;                    
  volatile const  uint32_t PID7;                    
  volatile const  uint32_t PID0;                    
  volatile const  uint32_t PID1;                    
  volatile const  uint32_t PID2;                    
  volatile const  uint32_t PID3;                    
  volatile const  uint32_t CID0;                    
  volatile const  uint32_t CID1;                    
  volatile const  uint32_t CID2;                    
  volatile const  uint32_t CID3;                    
} ITM_Type;

 



 



























 



 



 



 









   







 



 
typedef struct
{
  volatile uint32_t CTRL;                    
  volatile uint32_t CYCCNT;                  
  volatile uint32_t CPICNT;                  
  volatile uint32_t EXCCNT;                  
  volatile uint32_t SLEEPCNT;                
  volatile uint32_t LSUCNT;                  
  volatile uint32_t FOLDCNT;                 
  volatile const  uint32_t PCSR;                    
  volatile uint32_t COMP0;                   
  volatile uint32_t MASK0;                   
  volatile uint32_t FUNCTION0;               
        uint32_t RESERVED0[1U];
  volatile uint32_t COMP1;                   
  volatile uint32_t MASK1;                   
  volatile uint32_t FUNCTION1;               
        uint32_t RESERVED1[1U];
  volatile uint32_t COMP2;                   
  volatile uint32_t MASK2;                   
  volatile uint32_t FUNCTION2;               
        uint32_t RESERVED2[1U];
  volatile uint32_t COMP3;                   
  volatile uint32_t MASK3;                   
  volatile uint32_t FUNCTION3;               
} DWT_Type;

 






















































 



 



 



 



 



 



 



























   







 



 
typedef struct
{
  volatile uint32_t SSPSR;                   
  volatile uint32_t CSPSR;                   
        uint32_t RESERVED0[2U];
  volatile uint32_t ACPR;                    
        uint32_t RESERVED1[55U];
  volatile uint32_t SPPR;                    
        uint32_t RESERVED2[131U];
  volatile const  uint32_t FFSR;                    
  volatile uint32_t FFCR;                    
  volatile const  uint32_t FSCR;                    
        uint32_t RESERVED3[759U];
  volatile const  uint32_t TRIGGER;                 
  volatile const  uint32_t FIFO0;                   
  volatile const  uint32_t ITATBCTR2;               
        uint32_t RESERVED4[1U];
  volatile const  uint32_t ITATBCTR0;               
  volatile const  uint32_t FIFO1;                   
  volatile uint32_t ITCTRL;                  
        uint32_t RESERVED5[39U];
  volatile uint32_t CLAIMSET;                
  volatile uint32_t CLAIMCLR;                
        uint32_t RESERVED7[8U];
  volatile const  uint32_t DEVID;                   
  volatile const  uint32_t DEVTYPE;                 
} TPI_Type;

 



 



 












 






 



 





















 



 





















 



 



 


















 






   








 



 
typedef struct
{
  volatile const  uint32_t TYPE;                    
  volatile uint32_t CTRL;                    
  volatile uint32_t RNR;                     
  volatile uint32_t RBAR;                    
  volatile uint32_t RASR;                    
  volatile uint32_t RBAR_A1;                 
  volatile uint32_t RASR_A1;                 
  volatile uint32_t RBAR_A2;                 
  volatile uint32_t RASR_A2;                 
  volatile uint32_t RBAR_A3;                 
  volatile uint32_t RASR_A3;                 
} MPU_Type;

 









 









 



 









 






























 









 



 
typedef struct
{
        uint32_t RESERVED0[1U];
  volatile uint32_t FPCCR;                   
  volatile uint32_t FPCAR;                   
  volatile uint32_t FPDSCR;                  
  volatile const  uint32_t MVFR0;                   
  volatile const  uint32_t MVFR1;                   
} FPU_Type;

 



























 



 












 
























 












 








 



 
typedef struct
{
  volatile uint32_t DHCSR;                   
  volatile  uint32_t DCRSR;                   
  volatile uint32_t DCRDR;                   
  volatile uint32_t DEMCR;                   
} CoreDebug_Type;

 




































 






 







































 







 






 







 


 







 

 
#line 1541 "..\\..\\Library\\CMSIS\\Include\\core_cm4.h"

#line 1550 "..\\..\\Library\\CMSIS\\Include\\core_cm4.h"











 










 


 



 





 









 
static __inline void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);              

  reg_value  =  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR;                                                    
  reg_value &= ~((uint32_t)((0xFFFFUL << 16U) | (7UL << 8U)));  
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << 16U) |
                (PriorityGroupTmp << 8U)                      );               
  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR =  reg_value;
}






 
static __inline uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8U)) >> 8U));
}






 
static __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
{
  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
}






 
static __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
{
  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
}








 
static __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
{
  return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
}






 
static __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
{
  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
}






 
static __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
}








 
static __inline uint32_t NVIC_GetActive(IRQn_Type IRQn)
{
  return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IABR[(((uint32_t)(int32_t)IRQn) >> 5UL)] & (1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
}








 
static __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - 4UL)) & (uint32_t)0xFFUL);
  }
  else
  {
    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - 4UL)) & (uint32_t)0xFFUL);
  }
}










 
static __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
{

  if ((int32_t)(IRQn) < 0)
  {
    return(((uint32_t)((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] >> (8U - 4UL)));
  }
  else
  {
    return(((uint32_t)((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[((uint32_t)(int32_t)IRQn)]               >> (8U - 4UL)));
  }
}












 
static __inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);    
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(4UL)) ? (uint32_t)(4UL) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(4UL)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(4UL));

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
         );
}












 
static __inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);    
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(4UL)) ? (uint32_t)(4UL) : (uint32_t)(7UL - PriorityGroupTmp);
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(4UL)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(4UL));

  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
}





 
static __inline void NVIC_SystemReset(void)
{
  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                          
 
  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = (uint32_t)((0x5FAUL << 16U)    |
                           (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR & (7UL << 8U)) |
                            (1UL << 2U)    );          
  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                           

  for(;;)                                                            
  {
    __nop();
  }
}

 



 





 













 
static __inline uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > (0xFFFFFFUL ))
  {
    return (1UL);                                                    
  }

  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (uint32_t)(ticks - 1UL);                          
  NVIC_SetPriority (SysTick_IRQn, (1UL << 4UL) - 1UL);  
  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0UL;                                              
  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2U) |
                   (1UL << 1U)   |
                   (1UL );                          
  return (0UL);                                                      
}



 



 





 

extern volatile int32_t ITM_RxBuffer;                     










 
static __inline uint32_t ITM_SendChar (uint32_t ch)
{
  if (((((ITM_Type *) (0xE0000000UL) )->TCR & (1UL )) != 0UL) &&       
      ((((ITM_Type *) (0xE0000000UL) )->TER & 1UL               ) != 0UL)   )      
  {
    while (((ITM_Type *) (0xE0000000UL) )->PORT[0U].u32 == 0UL)
    {
      __nop();
    }
    ((ITM_Type *) (0xE0000000UL) )->PORT[0U].u8 = (uint8_t)ch;
  }
  return (ch);
}







 
static __inline int32_t ITM_ReceiveChar (void)
{
  int32_t ch = -1;                            

  if (ITM_RxBuffer != 0x5AA55AA5U)
  {
    ch = ITM_RxBuffer;
    ITM_RxBuffer = 0x5AA55AA5U;        
  }

  return (ch);
}







 
static __inline int32_t ITM_CheckChar (void)
{

  if (ITM_RxBuffer == 0x5AA55AA5U)
  {
    return (0);                               
  }
  else
  {
    return (1);                               
  }
}

 










#line 208 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 1 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\system_ma35d1_rtp.h"
 





 








#line 17 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\system_ma35d1_rtp.h"




 

#line 29 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\system_ma35d1_rtp.h"




extern uint32_t SystemCoreClock;      
extern uint32_t CyclesPerUs;          
extern uint32_t PllClock;             










 
extern void SystemInit (void);









 
extern void SystemCoreClockUpdate (void);







#line 209 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 210 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"




#pragma anon_unions


 
 
 
#line 1 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\sys_reg.h"
 





 




    #pragma anon_unions





 




 

typedef struct
{


































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































 
    volatile const  uint32_t PDID;                   
    volatile const  uint32_t PWRONOTP;               
    volatile const  uint32_t PWRONPIN;               
    volatile const  uint32_t RESERVE0[1];
    volatile uint32_t RSTSTS;                 
    volatile uint32_t MISCRFCR;               
    volatile uint32_t RSTDEBCTL;              
    volatile uint32_t LVRDCR;                 
    volatile uint32_t IPRST0;                 
    volatile uint32_t IPRST1;                 
    volatile uint32_t IPRST2;                 
    volatile uint32_t IPRST3;                 
    volatile uint32_t PMUCR;                  
    volatile uint32_t DDRCQCSR;               
    volatile uint32_t PMUIEN;                 
    volatile uint32_t PMUSTS;                 
    volatile uint32_t CA35WRBADR0;            
    volatile uint32_t CA35WRBPAR0;            
    volatile uint32_t CA35WRBADR1;            
    volatile uint32_t CA35WRBPAR1;            
    volatile const  uint32_t RESERVE1[4];
    volatile uint32_t USBPMISCR;              
    volatile uint32_t USBP0PCR;               
    volatile uint32_t USBP1PCR;               
    volatile const  uint32_t RESERVE2[1];
    volatile uint32_t MISCFCR0;               
    volatile uint32_t MISCFCR1;               
    volatile uint32_t MISCIER;                
    volatile uint32_t MISCISR;                
    volatile uint32_t GPA_MFPL;               
    volatile uint32_t GPA_MFPH;               
    volatile uint32_t GPB_MFPL;               
    volatile uint32_t GPB_MFPH;               
    volatile uint32_t GPC_MFPL;               
    volatile uint32_t GPC_MFPH;               
    volatile uint32_t GPD_MFPL;               
    volatile uint32_t GPD_MFPH;               
    volatile uint32_t GPE_MFPL;               
    volatile uint32_t GPE_MFPH;               
    volatile uint32_t GPF_MFPL;               
    volatile uint32_t GPF_MFPH;               
    volatile uint32_t GPG_MFPL;               
    volatile uint32_t GPG_MFPH;               
    volatile uint32_t GPH_MFPL;               
    volatile uint32_t GPH_MFPH;               
    volatile uint32_t GPI_MFPL;               
    volatile uint32_t GPI_MFPH;               
    volatile uint32_t GPJ_MFPL;               
    volatile uint32_t GPJ_MFPH;               
    volatile uint32_t GPK_MFPL;               
    volatile uint32_t GPK_MFPH;               
    volatile uint32_t GPL_MFPL;               
    volatile uint32_t GPL_MFPH;               
    volatile uint32_t GPM_MFPL;               
    volatile uint32_t GPM_MFPH;               
    volatile uint32_t GPN_MFPL;               
    volatile uint32_t GPN_MFPH;               
    volatile const  uint32_t RESERVE3[5];
    volatile uint32_t TSENSRFCR;              
    volatile uint32_t GMAC0MISCR;             
    volatile uint32_t GMAC1MISCR;             
    volatile const  uint32_t MACAD0LSR;              
    volatile const  uint32_t MACAD0HSR;              
    volatile const  uint32_t MACAD1LSR;              
    volatile const  uint32_t MACAD1HSR;              
    volatile uint32_t CSDBGCTL;               
    volatile const  uint32_t RESERVE4[7];
    volatile uint32_t GPAB_MFOS;              
    volatile uint32_t GPCD_MFOS;              
    volatile uint32_t GPEF_MFOS;              
    volatile uint32_t GPGH_MFOS;              
    volatile uint32_t GPIJ_MFOS;              
    volatile uint32_t GPKL_MFOS;              
    volatile uint32_t GPMN_MFOS;              
    volatile const  uint32_t RESERVE5[9];
    volatile const  uint32_t UID0;                   
    volatile const  uint32_t UID1;                   
    volatile const  uint32_t UID2;                   
    volatile const  uint32_t RESERVE6[1];
    volatile const  uint32_t UCID0;                  
    volatile const  uint32_t UCID1;                  
    volatile const  uint32_t UCID2;                  
    volatile const  uint32_t RESERVE7[1];
    volatile  uint32_t RLKTZS;                 
    volatile  uint32_t RLKTZNS;                
    volatile  uint32_t RLKSUBM;                

} SYS_T;




 


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































   
   
   


    #pragma no_anon_unions


#line 221 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 1 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\clk_reg.h"
 





 




    #pragma anon_unions





 

typedef struct
{
    


















































































 
    volatile uint32_t CTL0;               
    volatile uint32_t CTL1;               
    volatile uint32_t CTL2;               
    volatile uint32_t RESERVE;            

} PLL_T;




 

typedef struct
{

















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































 
    volatile uint32_t PWRCTL;                 
    volatile uint32_t SYSCLK0;                
    volatile uint32_t SYSCLK1;                
    volatile uint32_t APBCLK0;                
    volatile uint32_t APBCLK1;                
    volatile uint32_t APBCLK2;                
    volatile uint32_t CLKSEL0;                
    volatile uint32_t CLKSEL1;                
    volatile uint32_t CLKSEL2;                
    volatile uint32_t CLKSEL3;                
    volatile uint32_t CLKSEL4;                
    volatile uint32_t CLKDIV0;                
    volatile uint32_t CLKDIV1;                
    volatile uint32_t CLKDIV2;                
    volatile uint32_t CLKDIV3;                
    volatile uint32_t CLKDIV4;                
    volatile uint32_t CLKOCTL;                
    volatile const  uint32_t RESERVE0[3];
    volatile const  uint32_t STATUS;                 
    volatile const  uint32_t RESERVE1[3];
    volatile uint32_t PLL0CTL0;               
    volatile const  uint32_t RESERVE2[7];
    PLL_T PLL[4];                         
    volatile uint32_t CLKDCTL;                
    volatile uint32_t CLKDSTS;                
    volatile uint32_t CDUPB;                  
    volatile uint32_t CDLOWB;                 
    volatile uint32_t CKFLTRCTL;              

} CLK_T;




 




























































































































































































































































































































































































































































































































































































































































































































































































































































































































   
   
   


    #pragma no_anon_unions


#line 222 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"

#line 1 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\uart_reg.h"
 





 




#pragma anon_unions





 




 
 
typedef struct
{




















































































































































































































































































































































































































































































































































































































































































 
    volatile uint32_t DAT;                    
    volatile uint32_t INTEN;                  
    volatile uint32_t FIFO;                   
    volatile uint32_t LINE;                   
    volatile uint32_t MODEM;                  
    volatile uint32_t MODEMSTS;               
    volatile uint32_t FIFOSTS;                
    volatile uint32_t INTSTS;                 
    volatile uint32_t TOUT;                   
    volatile uint32_t BAUD;                   
    volatile uint32_t IRDA;                   
    volatile uint32_t ALTCTL;                 
    volatile uint32_t FUNCSEL;                
    volatile const  uint32_t RESERVE0[2];
    volatile uint32_t BRCOMP;                 
    volatile uint32_t WKCTL;                  
    volatile uint32_t WKSTS;                  
    volatile uint32_t DWKCOMP;                

} UART_T;




 




















































































































































































































































































































































   
   
   


#pragma no_anon_unions


#line 224 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 1 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\whc_reg.h"
 





 




#pragma anon_unions





 



 

typedef struct
{














































































































































































































































































































































































































































































































































































































































































































































 
    volatile uint32_t WKCTL;                  
    volatile uint32_t INTEN;                  
    volatile uint32_t INTSTS;                 
    volatile const  uint32_t RESERVE0[13];
    volatile uint32_t CPSTS;                  
    volatile const  uint32_t RESERVE1[15];
    volatile  uint32_t GINTTRG;                
    volatile const  uint32_t RESERVE2[15];
    volatile  uint32_t TXCTL;                  
    volatile const  uint32_t TXSTS;                  
    volatile  uint32_t RXCTL;                  
    volatile const  uint32_t RXSTS;                  
    volatile const  uint32_t RESERVE3[12];
    volatile  uint32_t TMDAT[4][4];            
    volatile const  uint32_t RESERVE4[48];
    volatile const  uint32_t RMDAT[4][4];            
} WHC_T;




 



































































































































































































































































   
   
   


#pragma no_anon_unions


#line 225 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 1 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\hwsem_reg.h"
 





 




#pragma anon_unions





 




 

typedef struct
{




















































































































































































































































































 
    volatile uint32_t CTL;                    
    volatile uint32_t INTENA35;               
    volatile uint32_t INTENM4;                
    volatile uint32_t INTSTSA35;              
    volatile uint32_t INTSTSM4;               
    volatile const  uint32_t RESERVE0[3];
    volatile uint32_t SEM[8];                 
} HWSEM_T;




 































































































































   
   
   


#pragma no_anon_unions


#line 226 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 1 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\wdt_reg.h"
 





 




#pragma anon_unions





 




 

typedef struct
{
































































































 
    volatile uint32_t CTL;                    
    volatile uint32_t ALTCTL;                 
    volatile  uint32_t RSTCNT;                 

} WDT_T;




 





































   
   
   


#pragma no_anon_unions


#line 227 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 1 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\wwdt_reg.h"
 





 




#pragma anon_unions





 




 

typedef struct
{








































































 
    volatile  uint32_t RLDCNT;                 
    volatile uint32_t CTL;                    
    volatile uint32_t STATUS;                 
    volatile const  uint32_t CNT;                    

} WWDT_T;




 




























   
   
   


#pragma no_anon_unions


#line 228 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 1 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\adc_reg.h"
 





 





#pragma anon_unions





 




 

typedef struct
{

























































































































































































































 
    volatile uint32_t CTL;                    
    volatile uint32_t CONF;                   
    volatile uint32_t IER;                    
    volatile uint32_t ISR;                    
    volatile const  uint32_t WKISR;                  
    volatile const  uint32_t RESERVE0[3];
    volatile const  uint32_t XYDATA;                 
    volatile const  uint32_t ZDATA;                  
    volatile const  uint32_t DATA;                   
    volatile const  uint32_t RESERVE1[114];
    volatile const  uint32_t XYSORT[4];              
    volatile const  uint32_t ZSORT0[4];              

} ADC_T;




 







































































































   
   
   


#pragma no_anon_unions





#line 229 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 1 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\eadc_reg.h"
 





 




#pragma anon_unions





 




 
 
typedef struct
{




































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































 
    volatile const  uint32_t DAT[19];                
    volatile const  uint32_t CURDAT;                 
    volatile uint32_t CTL;                    
    volatile  uint32_t SWTRG;                  
    volatile uint32_t PENDSTS;                
    volatile uint32_t OVSTS;                  
    
    volatile const  uint32_t RESERVE0[8];
    
    volatile uint32_t SCTL[19];               
    
    volatile const  uint32_t RESERVE1[1];
    
    volatile uint32_t INTSRC[4];              
    volatile uint32_t CMP[4];                 
    volatile const  uint32_t STATUS0;                
    volatile const  uint32_t STATUS1;                
    volatile uint32_t STATUS2;                
    volatile const  uint32_t STATUS3;                
    volatile const  uint32_t DDAT[4];                
    volatile uint32_t PWRM;                   
    volatile uint32_t CALCTL;                 
    volatile uint32_t CALDWRD;                
    
    volatile const  uint32_t RESERVE2[5];
    
    volatile uint32_t PDMACTL;                
    volatile const  uint32_t RESERVE5[3];
    volatile uint32_t SELSMP0;                
    volatile uint32_t SELSMP1;                
    volatile const  uint32_t RESERVE6[2];
    volatile uint32_t REFADJCTL;              

} EADC_T;




 























































































































































































































































































































































































































































































































































































































































































































































   
   
   


#pragma no_anon_unions


#line 230 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 1 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\sc_reg.h"
 





 




#pragma anon_unions





 




 

typedef struct
{




































































































































































































































































































































































































































































































































































































































 
    volatile uint32_t DAT;                    
    volatile uint32_t CTL;                    
    volatile uint32_t ALTCTL;                 
    volatile uint32_t EGT;                    
    volatile uint32_t RXTOUT;                 
    volatile uint32_t ETUCTL;                 
    volatile uint32_t INTEN;                  
    volatile uint32_t INTSTS;                 
    volatile uint32_t STATUS;                 
    volatile uint32_t PINCTL;                 
    volatile uint32_t TMRCTL0;                
    volatile uint32_t TMRCTL1;                
    volatile uint32_t TMRCTL2;                
    volatile uint32_t UARTCTL;                
    volatile const  uint32_t RESERVE0[5];
    volatile uint32_t ACTCTL;                 

} SC_T;




 













































































































































































































































































































   
   
   


#pragma no_anon_unions


#line 231 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 1 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\gpio_reg.h"
 





 




#pragma anon_unions





 




 


typedef struct
{

    













































































































































































































































































































































































































































 

    volatile uint32_t MODE;           
    volatile uint32_t DINOFF;         
    volatile uint32_t DOUT;           
    volatile uint32_t DATMSK;         
    volatile const  uint32_t PIN;            
    volatile uint32_t DBEN;           
    volatile uint32_t INTTYPE;        
    volatile uint32_t INTEN;          
    volatile uint32_t INTSRC;         
    volatile uint32_t SMTEN;          
    volatile uint32_t SLEWCTL;        
    
    volatile const  uint32_t RESERVE0[1];
    
    volatile uint32_t PUSEL;          
    volatile uint32_t DBCTL;          
    volatile uint32_t DS;             
    volatile uint32_t UDS;            
} GPIO_T;




 


























































































































































































































































































































































































































































































































































































































































































































































   
   
   


#pragma no_anon_unions


#line 232 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 1 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ecap_reg.h"
 





 




#pragma anon_unions





 




 

typedef struct
{

    

















































































































































































































 
    volatile uint32_t CNT;                    
    volatile uint32_t HLD0;                   
    volatile uint32_t HLD1;                   
    volatile uint32_t HLD2;                   
    volatile uint32_t CNTCMP;                 
    volatile uint32_t CTL0;                   
    volatile uint32_t CTL1;                   
    volatile uint32_t STATUS;                 

} ECAP_T;




 































































































































   
   
   


#pragma no_anon_unions


#line 233 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 1 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\qei_reg.h"
 





 




#pragma anon_unions





 




 

typedef struct
{


    






























































































































































 
    volatile uint32_t CNT;                    
    volatile uint32_t CNTHOLD;                
    volatile uint32_t CNTLATCH;               
    volatile uint32_t CNTCMP;                 
    
    volatile const  uint32_t RESERVE0[1];
    
    volatile uint32_t CNTMAX;                 
    volatile uint32_t CTL;                    
    
    volatile const  uint32_t RESERVE1[4];
    
    volatile uint32_t STATUS;                 

} QEI_T;




 

































































































   
   
   


#pragma no_anon_unions


#line 234 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 1 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\i2c_reg.h"
 





 




#pragma anon_unions





 

 



 
 
typedef struct
{










































































































































































































































































 
    volatile uint32_t CTL0;                   
    volatile uint32_t ADDR0;                  
    volatile uint32_t DAT;                    
    volatile const  uint32_t STATUS0;                
    volatile uint32_t CLKDIV;                 
    volatile uint32_t TOCTL;                  
    volatile uint32_t ADDR1;                  
    volatile uint32_t ADDR2;                  
    volatile uint32_t ADDR3;                  
    volatile uint32_t ADDRMSK0;               
    volatile uint32_t ADDRMSK1;               
    volatile uint32_t ADDRMSK2;               
    volatile uint32_t ADDRMSK3;               
    volatile const  uint32_t RESERVE0[2];
    volatile uint32_t WKCTL;                  
    volatile uint32_t WKSTS;                  
    volatile uint32_t CTL1;                   
    volatile uint32_t STATUS1;                
    volatile uint32_t TMCTL;                  

} I2C_T;




 




























































































































   
   
   


#pragma no_anon_unions


#line 235 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 1 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\i2s_reg.h"
 





 




#pragma anon_unions





 




 
 
typedef struct
{
















































































































































































































































































































































































































































 
    volatile uint32_t CTL0;                   
    volatile uint32_t CLKDIV;                 
    volatile uint32_t IEN;                    
    volatile uint32_t STATUS0;                
    volatile  uint32_t TXFIFO;                 
    volatile const  uint32_t RXFIFO;                 
    volatile const  uint32_t RESERVE0[2];
    volatile uint32_t CTL1;                   
    volatile uint32_t STATUS1;                

} I2S_T;




 




























































































































































































































   
   
   


#pragma no_anon_unions


#line 236 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 1 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\pdma_reg.h"
 





 




#pragma anon_unions





 




 


typedef struct
{

    





















































































 
    volatile uint32_t CTL;              
    volatile uint32_t SA;               
    volatile uint32_t DA;               
    volatile uint32_t NEXT;             
} DSCT_T;


typedef struct
{
    
















 
    volatile uint32_t STCR;            
    volatile uint32_t ASOCR;           
} STRIDE_T;

typedef struct
{
    
















 
    volatile uint32_t AICTL;          
    volatile uint32_t RCNT;           
} REPEAT_T;

typedef struct
{


    





















































































































































































































































































































































































































































































































































































 
    DSCT_T DSCT[10];
    volatile const  uint32_t CURSCAT[10];            
    
    DSCT_T RESERVE1[6];
    
    
    volatile const  uint32_t RESERVE2[6];
    
    
    volatile const  uint32_t RESERVE3[176];
    
    volatile uint32_t CHCTL;                  
    volatile  uint32_t PAUSE;                  
    volatile  uint32_t SWREQ;                  
    volatile const  uint32_t TRGSTS;                 
    volatile uint32_t PRISET;                 
    volatile  uint32_t PRICLR;                 
    volatile uint32_t INTEN;                  
    volatile uint32_t INTSTS;                 
    volatile uint32_t ABTSTS;                 
    volatile uint32_t TDSTS;                  
    volatile uint32_t ALIGN;                  
    volatile const  uint32_t TACTSTS;                
    
    volatile const  uint32_t RESERVE4[1];
    
    volatile uint32_t TOUTEN;                 
    volatile uint32_t TOUTIEN;                
    
    volatile uint32_t RESERVE5[1];
    
    volatile uint32_t TOC0_1;                 
    volatile uint32_t TOC2_3;                 
    volatile uint32_t TOC4_5;                 
    volatile uint32_t TOC6_7;                 
    volatile uint32_t TOC8_9;                 
    
    volatile const  uint32_t RESERVE6[3];
    
    volatile uint32_t CHRST;                  
    
    volatile const  uint32_t RESERVE7[3];
    
    volatile uint32_t TOUTPSC;                
    volatile uint32_t TOUTPSC1;               
    
    volatile const  uint32_t RESERVE8[2];
    
    volatile uint32_t REQSEL0_3;              
    volatile uint32_t REQSEL4_7;              
    volatile uint32_t REQSEL8_11;             
    
    volatile const  uint32_t RESERVE9[29];
    
    STRIDE_T     STRIDE[6];
    
    volatile uint32_t RESERVE10[52];
    
    REPEAT_T    REPEAT[2];
} PDMA_T;




 










































































































































































































































































































   
   
   


#pragma no_anon_unions


#line 237 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 1 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\qspi_reg.h"
 





 




#pragma anon_unions





 




 
 
typedef struct
{
























































































































































































































































































































































































 
    volatile uint32_t CTL;                    
    volatile uint32_t CLKDIV;                 
    volatile uint32_t SSCTL;                  
    volatile uint32_t PDMACTL;                
    volatile uint32_t FIFOCTL;                
    volatile uint32_t STATUS;                 
    volatile const  uint32_t STATUS2;                
    volatile const  uint32_t RESERVE0[1];
    volatile  uint32_t TX;                     
    volatile const  uint32_t RESERVE1[3];
    volatile const  uint32_t RX;                     

} QSPI_T;




 































































































































































































































   
   
   


#pragma no_anon_unions


#line 238 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 1 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\spi_reg.h"
 





 




#pragma anon_unions





 




 
 
typedef struct
{






































































































































































































































































































































































































































































































































 
    volatile uint32_t CTL;                    
    volatile uint32_t CLKDIV;                 
    volatile uint32_t SSCTL;                  
    volatile uint32_t PDMACTL;                
    volatile uint32_t FIFOCTL;                
    volatile uint32_t STATUS;                 
    volatile const  uint32_t STATUS2;                
    volatile const  uint32_t RESERVE0[1];
    volatile  uint32_t TX;                     
    volatile const  uint32_t RESERVE1[3];
    volatile const  uint32_t RX;                     
    volatile const  uint32_t RESERVE2[11];
    volatile uint32_t I2SCTL;                 
    volatile uint32_t I2SCLK;                 
    volatile uint32_t I2SSTS;                 

} SPI_T;




 






















































































































































































































































































































   
   
   


#pragma no_anon_unions


#line 239 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 1 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\rtc_reg.h"
 





 




#pragma anon_unions





 



 



 
 
typedef struct
{







































































































































































































































































































































































































































































































































































































































































































































































 
    volatile uint32_t INIT;                   
    volatile const  uint32_t SINFASTS;               
    volatile uint32_t FREQADJ;                
    volatile uint32_t TIME;                   
    volatile uint32_t CAL;                    
    volatile uint32_t CLKFMT;                 
    volatile uint32_t WEEKDAY;                
    volatile uint32_t TALM;                   
    volatile uint32_t CALM;                   
    volatile const  uint32_t LEAPYEAR;               
    volatile uint32_t INTEN;                  
    volatile uint32_t INTSTS;                 
    volatile uint32_t TICK;                   
    volatile uint32_t TAMSK;                  
    volatile uint32_t CAMSK;                  
    volatile uint32_t SPRCTL;                 
    volatile uint32_t SPR0;                   
    volatile uint32_t SPR1;                   
    volatile uint32_t SPR2;                   
    volatile uint32_t SPR3;                   
    volatile uint32_t SPR4;                   
    volatile uint32_t SPR5;                   
    volatile uint32_t SPR6;                   
    volatile uint32_t SPR7;                   
    volatile uint32_t SPR8;                   
    volatile uint32_t SPR9;                   
    volatile uint32_t SPR10;                  
    volatile uint32_t SPR11;                  
    volatile uint32_t SPR12;                  
    volatile uint32_t SPR13;                  
    volatile uint32_t SPR14;                  
    volatile uint32_t SPR15;                  
    volatile const  uint32_t RESERVE0[7];
    volatile uint32_t TALM_M;                 
    volatile uint32_t CALM_M;                 
    volatile const  uint32_t RESERVE1[1];
    volatile uint32_t INTEN_M;                
    volatile uint32_t INTSTS_M;               
    volatile uint32_t TICK_M;                 
    volatile uint32_t TAMSK_M;                
    volatile uint32_t CAMSK_M;                
    volatile const  uint32_t RESERVE2[17];
    volatile uint32_t LXTCTL;                 
    volatile uint32_t GPIOCTL0;               
    volatile const  uint32_t RESERVE3[6];
    volatile uint32_t TAMPCTL;                
    volatile const  uint32_t RESERVE4[1];
    volatile uint32_t TAMPSEED;               
    volatile const  uint32_t RESERVE5[1];
    volatile const  uint32_t TAMPTIME;               
    volatile const  uint32_t TAMPCAL;                
    volatile const  uint32_t RESERVE6[2];
    volatile uint32_t CLKDCTL;                
    volatile uint32_t CDBR;                   
    volatile const  uint32_t RESERVE7[14];
    volatile uint32_t PWRCTL;                 
    volatile const  uint32_t PWRSTS;                 

} RTC_T;




 
























































































































































































































































































































































































































































































   
   
   


#pragma no_anon_unions


#line 240 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 1 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\timer_reg.h"
 





 




#pragma anon_unions





 




 

typedef struct
{








































































































































































































































































































































































































































































































































































































































































































 
    volatile uint32_t CTL;                    
    volatile uint32_t CMP;                    
    volatile uint32_t INTSTS;                 
    volatile uint32_t CNT;                    
    volatile const  uint32_t CAP;                    
    volatile uint32_t EXTCTL;                 
    volatile uint32_t EINTSTS;                
    volatile uint32_t TRGCTL;                 
    volatile uint32_t ALTCTL;                 
    volatile const  uint32_t RESERVE0[7];
    volatile uint32_t PWMCTL;                 
    volatile uint32_t PWMCLKSRC;              
    volatile uint32_t PWMCLKPSC;              
    volatile uint32_t PWMCNTCLR;              
    volatile uint32_t PWMPERIOD;              
    volatile uint32_t PWMCMPDAT;              
    volatile uint32_t PWMDTCTL;               
    volatile const  uint32_t PWMCNT;                 
    volatile uint32_t PWMMSKEN;               
    volatile uint32_t PWMMSK;                 
    volatile uint32_t PWMBNF;                 
    volatile uint32_t PWMFAILBRK;             
    volatile uint32_t PWMBRKCTL;              
    volatile uint32_t PWMPOLCTL;              
    volatile uint32_t PWMPOEN;                
    volatile  uint32_t PWMSWBRK;               
    volatile uint32_t PWMINTEN0;              
    volatile uint32_t PWMINTEN1;              
    volatile uint32_t PWMINTSTS0;             
    volatile uint32_t PWMINTSTS1;             
    volatile uint32_t PWMEADCTS;              
    volatile uint32_t PWMSCTL;                
    volatile  uint32_t PWMSTRG;                
    volatile uint32_t PWMSTATUS;              
    volatile const  uint32_t PWMPBUF;                
    volatile const  uint32_t PWMCMPBUF;              

} TIMER_T;




 






















































































































































































































































































































   
   
   


#pragma no_anon_unions


#line 241 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 1 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ebi_reg.h"
 





 




#pragma anon_unions





 




 

typedef struct
{












































































































































































































 
    volatile uint32_t CTL0;                   
    volatile uint32_t TCTL0;                  
    
    volatile const  uint32_t RESERVE0[2];
    
    volatile uint32_t CTL1;                   
    volatile uint32_t TCTL1;                  
    
    volatile const  uint32_t RESERVE1[2];
    
    volatile uint32_t CTL2;                   
    volatile uint32_t TCTL2;                  

} EBI_T;




 









































































































































































   
   
   


#pragma no_anon_unions


#line 242 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 1 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\epwm_reg.h"
 





 




#pragma anon_unions





 

 



 
 
typedef struct
{
    














 
    volatile uint32_t RCAPDAT;  
    volatile uint32_t FCAPDAT;  
} ECAPDAT_T;

typedef struct
{


















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































 
    volatile uint32_t CTL0;                   
    volatile uint32_t CTL1;                   
    volatile uint32_t SYNC;                   
    volatile uint32_t SWSYNC;                 
    volatile uint32_t CLKSRC;                 
    volatile uint32_t CLKPSC[3];              
    volatile uint32_t CNTEN;                  
    volatile uint32_t CNTCLR;                 
    volatile uint32_t LOAD;                   
    
    volatile const  uint32_t RESERVE0[1];
    
    volatile uint32_t PERIOD[6];              
    
    volatile const  uint32_t RESERVE1[2];
    
    volatile uint32_t CMPDAT[6];              
    
    volatile const  uint32_t RESERVE2[2];
    
    volatile uint32_t DTCTL[3];               
    
    volatile const  uint32_t RESERVE3[1];
    
    volatile uint32_t PHS[3];                 
    
    volatile const  uint32_t RESERVE4[1];
    
    volatile const  uint32_t CNT[6];                 
    
    volatile const  uint32_t RESERVE5[2];
    
    volatile uint32_t WGCTL0;                 
    volatile uint32_t WGCTL1;                 
    volatile uint32_t MSKEN;                  
    volatile uint32_t MSK;                    
    volatile uint32_t BNF;                    
    volatile uint32_t FAILBRK;                
    volatile uint32_t BRKCTL[3];              
    volatile uint32_t POLCTL;                 
    volatile uint32_t POEN;                   
    volatile  uint32_t SWBRK;                  
    volatile uint32_t INTEN0;                 
    volatile uint32_t INTEN1;                 
    volatile uint32_t INTSTS0;                
    volatile uint32_t INTSTS1;                
    
    volatile const  uint32_t RESERVE6[1];
    
    volatile uint32_t DACTRGEN;               
    volatile uint32_t EADCTS0;                
    volatile uint32_t EADCTS1;                
    volatile uint32_t FTCMPDAT[3];            
    
    volatile const  uint32_t RESERVE7[1];
    
    volatile uint32_t SSCTL;                  
    volatile  uint32_t SSTRG;                  
    volatile uint32_t LEBCTL;                 
    volatile uint32_t LEBCNT;                 
    volatile uint32_t STATUS;                 
    
    volatile const  uint32_t RESERVE8[3];
    
    volatile uint32_t IFA[6];                 
    
    volatile const  uint32_t RESERVE9[2];
    
    volatile uint32_t AINTSTS;                
    volatile uint32_t AINTEN;                 
    volatile uint32_t APDMACTL;               
    
    volatile const  uint32_t RESERVE10[1];
    
    volatile uint32_t FDEN;                   
    volatile uint32_t FDCTL[6];               
    volatile uint32_t FDIEN;                  
    volatile uint32_t FDSTS;                  
    volatile uint32_t EADCPSCCTL;             
    volatile uint32_t EADCPSC0;               
    volatile uint32_t EADCPSC1;               
    volatile uint32_t EADCPSCNT0;             
    volatile uint32_t EADCPSCNT1;             
    
    volatile const  uint32_t RESERVE11[26];
    
    volatile uint32_t CAPINEN;                
    volatile uint32_t CAPCTL;                 
    volatile const  uint32_t CAPSTS;                 
    ECAPDAT_T CAPDAT[6];                   
    volatile uint32_t PDMACTL;                
    volatile const  uint32_t PDMACAP[3];             
    
    volatile const  uint32_t RESERVE12[1];
    
    volatile uint32_t CAPIEN;                 
    volatile uint32_t CAPIF;                  
    
    volatile const  uint32_t RESERVE13[43];
    
    volatile const  uint32_t PBUF[6];                
    volatile const  uint32_t CMPBUF[6];              
    volatile const  uint32_t CPSCBUF[3];             
    volatile const  uint32_t FTCBUF[3];              
    volatile uint32_t FTCI;                   

} EPWM_T;




 





















































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































   
   
   


#pragma no_anon_unions


#line 243 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 1 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\kpi_reg.h"
 






 




#pragma anon_unions





 




 
 
typedef struct
{






































































































































































































































































 
    volatile uint32_t KPICONF;                
    volatile uint32_t KPI3KCONF;              
    volatile uint32_t KPISTATUS;              
    volatile uint32_t KPIRSTC;                
    volatile const  uint32_t KPIKEST0;               
    volatile const  uint32_t KPIKEST1;               
    volatile uint32_t KPIKPE0;                
    volatile uint32_t KPIKPE1;                
    volatile uint32_t KPIKRE0;                
    volatile uint32_t KPIKRE1;                
    volatile uint32_t KPIPRESCALDIV;          

} KPI_T;




 



























































































   
   


#pragma no_anon_unions





#line 244 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 1 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\canfd_reg.h"
 





 





    #pragma anon_unions





 




 

typedef struct
{







































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































 
    volatile const  uint32_t RESERVE0[3];
    volatile uint32_t DBTP;                   
    volatile uint32_t TEST;                   
    volatile uint32_t RWD;                    
    volatile uint32_t CCCR;                   
    volatile uint32_t NBTP;                   
    volatile uint32_t TSCC;                   
    volatile uint32_t TSCV;                   
    volatile uint32_t TOCC;                   
    volatile uint32_t TOCV;                   
    volatile const  uint32_t RESERVE1[4];
    volatile uint32_t ECR;                    
    volatile uint32_t PSR;                    
    volatile uint32_t TDCR;                   
    volatile const  uint32_t RESERVE2[1];
    volatile uint32_t IR;                     
    volatile uint32_t IE;                     
    volatile uint32_t ILS;                    
    volatile uint32_t ILE;                    
    volatile const  uint32_t RESERVE3[8];
    volatile uint32_t GFC;                    
    volatile uint32_t SIDFC;                  
    volatile uint32_t XIDFC;                  
    volatile const  uint32_t RESERVE4[1];
    volatile uint32_t XIDAM;                  
    volatile const  uint32_t HPMS;                   
    volatile uint32_t NDAT1;                  
    volatile uint32_t NDAT2;                  
    volatile uint32_t RXF0C;                  
    volatile const  uint32_t RXF0S;                  
    volatile uint32_t RXF0A;                  
    volatile uint32_t RXBC;                   
    volatile uint32_t RXF1C;                  
    volatile const  uint32_t RXF1S;                  
    volatile uint32_t RXF1A;                  
    volatile uint32_t RXESC;                  
    volatile uint32_t TXBC;                   
    volatile const  uint32_t TXFQS;                  
    volatile uint32_t TXESC;                  
    volatile const  uint32_t TXBRP;                  
    volatile uint32_t TXBAR;                  
    volatile uint32_t TXBCR;                  
    volatile const  uint32_t TXBTO;                  
    volatile const  uint32_t TXBCF;                  
    volatile uint32_t TXBTIE;                 
    volatile uint32_t TXBCIE;                 
    volatile const  uint32_t RESERVE5[2];
    volatile uint32_t TXEFC;                  
    volatile const  uint32_t TXEFS;                  
    volatile uint32_t TXEFA;                  

} CANFD_T;




 








































































































































































































































































































































































































































































































































































































































   
   
   


    #pragma no_anon_unions


#line 245 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"




 
 



 
#line 340 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"


   





 

#line 434 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"

   




 

typedef volatile uint8_t  vu8;        
typedef volatile uint16_t vu16;       
typedef volatile uint32_t vu32;       
typedef volatile uint64_t vu64;       





 







 







 








 







 








 







 







 






 








 







 








 







 







 






 



   

 
 
 



 











 
#line 622 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"

 










   


 
 
 
#line 1 "..\\..\\Library\\StdDriver\\inc\\sys.h"
 





 












 



 



 


 
 
 
#line 60 "..\\..\\Library\\StdDriver\\inc\\sys.h"

#line 85 "..\\..\\Library\\StdDriver\\inc\\sys.h"

#line 98 "..\\..\\Library\\StdDriver\\inc\\sys.h"

#line 127 "..\\..\\Library\\StdDriver\\inc\\sys.h"

 
 
 






 
 
#line 183 "..\\..\\Library\\StdDriver\\inc\\sys.h"
 
#line 237 "..\\..\\Library\\StdDriver\\inc\\sys.h"
 
#line 254 "..\\..\\Library\\StdDriver\\inc\\sys.h"
 
#line 352 "..\\..\\Library\\StdDriver\\inc\\sys.h"
 
#line 387 "..\\..\\Library\\StdDriver\\inc\\sys.h"
 
#line 434 "..\\..\\Library\\StdDriver\\inc\\sys.h"
 
#line 481 "..\\..\\Library\\StdDriver\\inc\\sys.h"
 
#line 566 "..\\..\\Library\\StdDriver\\inc\\sys.h"
 
#line 611 "..\\..\\Library\\StdDriver\\inc\\sys.h"
 
#line 650 "..\\..\\Library\\StdDriver\\inc\\sys.h"
 
#line 715 "..\\..\\Library\\StdDriver\\inc\\sys.h"
 
#line 775 "..\\..\\Library\\StdDriver\\inc\\sys.h"
 
#line 871 "..\\..\\Library\\StdDriver\\inc\\sys.h"
 
#line 929 "..\\..\\Library\\StdDriver\\inc\\sys.h"
 
#line 966 "..\\..\\Library\\StdDriver\\inc\\sys.h"
 
#line 986 "..\\..\\Library\\StdDriver\\inc\\sys.h"
 
#line 1061 "..\\..\\Library\\StdDriver\\inc\\sys.h"
 
#line 1102 "..\\..\\Library\\StdDriver\\inc\\sys.h"
 
#line 1171 "..\\..\\Library\\StdDriver\\inc\\sys.h"
 
#line 1229 "..\\..\\Library\\StdDriver\\inc\\sys.h"
 
#line 1306 "..\\..\\Library\\StdDriver\\inc\\sys.h"
 
#line 1374 "..\\..\\Library\\StdDriver\\inc\\sys.h"
 
#line 1468 "..\\..\\Library\\StdDriver\\inc\\sys.h"
 
#line 1574 "..\\..\\Library\\StdDriver\\inc\\sys.h"
 
#line 1620 "..\\..\\Library\\StdDriver\\inc\\sys.h"
 
#line 1690 "..\\..\\Library\\StdDriver\\inc\\sys.h"
 
#line 1719 "..\\..\\Library\\StdDriver\\inc\\sys.h"
 
#line 1767 "..\\..\\Library\\StdDriver\\inc\\sys.h"

   




 

 
 
 
 
static __inline void SYS_UnlockReg(void);
static __inline void SYS_LockReg(void);







 
static __inline void SYS_UnlockReg(void)
{
    do
    {
        ((SYS_T *) (0x40460000UL))->RLKSUBM = 0x59UL;
        ((SYS_T *) (0x40460000UL))->RLKSUBM = 0x16UL;
        ((SYS_T *) (0x40460000UL))->RLKSUBM = 0x88UL;
    }
    while (((SYS_T *) (0x40460000UL))->RLKSUBM == 0UL);
}







 
static __inline void SYS_LockReg(void)
{
    ((SYS_T *) (0x40460000UL))->RLKSUBM = 0UL;
}

void SYS_ResetModule(uint32_t u32ModuleIndex);

   

   

   








#line 641 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 1 "..\\..\\Library\\StdDriver\\inc\\clk.h"
 





 











 



 



 




#line 38 "..\\..\\Library\\StdDriver\\inc\\clk.h"

 
 
 
#line 73 "..\\..\\Library\\StdDriver\\inc\\clk.h"

 
 
 
#line 125 "..\\..\\Library\\StdDriver\\inc\\clk.h"

 
 
 
#line 169 "..\\..\\Library\\StdDriver\\inc\\clk.h"

 
 
 
#line 215 "..\\..\\Library\\StdDriver\\inc\\clk.h"


 
 
 
#line 259 "..\\..\\Library\\StdDriver\\inc\\clk.h"

 
 
 
#line 271 "..\\..\\Library\\StdDriver\\inc\\clk.h"

 
 
 
#line 283 "..\\..\\Library\\StdDriver\\inc\\clk.h"


 
 
 
#line 296 "..\\..\\Library\\StdDriver\\inc\\clk.h"

 
 
 






 
 
 




 
 
 

 

#line 329 "..\\..\\Library\\StdDriver\\inc\\clk.h"

#line 338 "..\\..\\Library\\StdDriver\\inc\\clk.h"

#line 456 "..\\..\\Library\\StdDriver\\inc\\clk.h"

   



 

 
 
 
 
static __inline void CLK_SysTickDelay(uint32_t us);
static __inline void CLK_SysTickLongDelay(uint32_t us);









 
static __inline void CLK_SysTickDelay(uint32_t us)
{
    ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD = us * CyclesPerUs;
    ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL  = 0x0UL;
    ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2U) | (1UL );

     
    while ((((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL & (1UL << 16U)) == 0UL)
    {
    }

     
    ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = 0UL;
}








 
static __inline void CLK_SysTickLongDelay(uint32_t us)
{
    uint32_t delay;

     
    delay = 349525UL;

    do
    {
        if (us > delay)
        {
            us -= delay;
        }
        else
        {
            delay = us;
            us = 0UL;
        }

        ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD = delay * CyclesPerUs;
        ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL  = (0x0UL);
        ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2U) | (1UL );

         
        while ((((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL & (1UL << 16U)) == 0UL);

         
        ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = 0UL;

    }
    while (us > 0UL);

}


void CLK_DisableCKO(void);
void CLK_EnableCKO(uint32_t u32ClkSrc, uint32_t u32ClkDiv, uint32_t u32ClkDivBy1En);
void CLK_PowerDown(void);
uint32_t CLK_GetHXTFreq(void);
uint32_t CLK_GetLXTFreq(void);
uint32_t CLK_GetSYSCLK0Freq(void);
uint32_t CLK_GetSYSCLK1Freq(void);
uint32_t CLK_GetPCLK0Freq(void);
uint32_t CLK_GetPCLK3Freq(void);
uint32_t CLK_GetCPUFreq(void);
uint32_t CLK_SetCoreClock(uint32_t u32Hclk);
void CLK_SetModuleClock(uint32_t u32ModuleIdx, uint32_t u32ClkSrc, uint32_t u32ClkDiv);
void CLK_SetSysTickClockSrc(uint32_t u32ClkSrc);
void CLK_EnableXtalRC(uint32_t u32ClkMask);
void CLK_DisableXtalRC(uint32_t u32ClkMask);
void CLK_EnableModuleClock(uint32_t u32ModuleIdx);
void CLK_DisableModuleClock(uint32_t u32ModuleIdx);
void CLK_DisablePLL(uint32_t u32PllIdx);
uint32_t CLK_WaitClockReady(uint32_t u32ClkMask);
void CLK_EnableSysTick(uint32_t u32ClkSrc, uint32_t u32Count);
void CLK_DisableSysTick(void);
uint32_t CLK_GetCAPLLClockFreq(void);
uint32_t CLK_GetPLLClockFreq(uint32_t u32PllIdx);
uint32_t CLK_GetModuleClockSource(uint32_t u32ModuleIdx);
uint32_t CLK_GetModuleClockDivider(uint32_t u32ModuleIdx);

   

   

   







#line 642 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"

#line 1 "..\\..\\Library\\StdDriver\\inc\\uart.h"
 





 












 



 



 

 
 
 

#line 40 "..\\..\\Library\\StdDriver\\inc\\uart.h"

 
 
 











 
 
 
















 
 
 




 
 
 




 
 
 






 
 
 




   




 












 













 













 












 













 













 














 












 













 













 













 













 













 





















 





















 


































 












 













 


 
static __inline void UART_CLEAR_RTS(UART_T* uart);
static __inline void UART_SET_RTS(UART_T* uart);










 
static __inline void UART_CLEAR_RTS(UART_T* uart)
{
    uart->MODEM |= (0x1ul << (9));
    uart->MODEM &= ~(0x1ul << (1));
}










 
static __inline void UART_SET_RTS(UART_T* uart)
{
    uart->MODEM |= (0x1ul << (9)) | (0x1ul << (1));
}












 












 



void UART_ClearIntFlag(UART_T* uart, uint32_t u32InterruptFlag);
void UART_Close(UART_T* uart);
void UART_DisableFlowCtrl(UART_T* uart);
void UART_DisableInt(UART_T*  uart, uint32_t u32InterruptFlag);
void UART_EnableFlowCtrl(UART_T* uart);
void UART_EnableInt(UART_T*  uart, uint32_t u32InterruptFlag);
void UART_Open(UART_T* uart, uint32_t u32baudrate);
uint32_t UART_Read(UART_T* uart, uint8_t pu8RxBuf[], uint32_t u32ReadBytes);
void UART_SetLineConfig(UART_T* uart, uint32_t u32baudrate, uint32_t u32data_width, uint32_t u32parity, uint32_t  u32stop_bits);
void UART_SetTimeoutCnt(UART_T* uart, uint32_t u32TOC);
void UART_SelectIrDAMode(UART_T* uart, uint32_t u32Buadrate, uint32_t u32Direction);
void UART_SelectRS485Mode(UART_T* uart, uint32_t u32Mode, uint32_t u32Addr);
uint32_t UART_Write(UART_T* uart, uint8_t pu8TxBuf[], uint32_t u32WriteBytes);




   

   

   







#line 644 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 1 "..\\..\\Library\\StdDriver\\inc\\hwsem.h"
 





 











 



 



 





   




 










 










 











 











 










 









 










 



 
static __inline int32_t HWSEM_Try_Lock(HWSEM_T *hwsem, uint32_t u32Num, uint8_t u8Key);
static __inline void HWSEM_Spin_Lock(HWSEM_T *hwsem, uint32_t u32Num, uint8_t u8Key);










 
static __inline int32_t HWSEM_Try_Lock(HWSEM_T *hwsem, uint32_t u32Num, uint8_t u8Key)
{
    ((hwsem)->SEM[(u32Num)] = ((u8Key) << (8)) & (0xfful << (8)));
    if((hwsem->SEM[u32Num] & (0xful << (0))) == 2ul &&
       (hwsem->SEM[u32Num] & (0xfful << (8))) == (u8Key << (8)))
        return 0;
    else
        return -1;
}









 
static __inline void HWSEM_Spin_Lock(HWSEM_T *hwsem, uint32_t u32Num, uint8_t u8Key)
{
    while(1)
    {
        ((hwsem)->SEM[(u32Num)] = ((u8Key) << (8)) & (0xfful << (8)));
        if((hwsem->SEM[u32Num] & (0xful << (0))) == 2ul &&
           (hwsem->SEM[u32Num] & (0xfful << (8))) == (u8Key << (8)))
            break;
    }
}

   

   

   







#line 645 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 1 "..\\..\\Library\\StdDriver\\inc\\whc.h"
 





 











 



 



 







   




 







 








 








 


























 



























 





























 


























 








 








 







 



























 



























 


int WHC_Send(WHC_T* whc, uint32_t u32Ch, uint32_t *pu32TxBuf);
int WHC_Recv(WHC_T* whc, uint32_t u32Ch, uint32_t *pu32RxBuf);
int WHC_GetCPSts(WHC_T* whc, uint32_t u32Core);


   

   

   







#line 646 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 1 "..\\..\\Library\\StdDriver\\inc\\gpio.h"
 





 











 



 



 





 
 
 






 
 
 







 
 
 



 
 
 




 
 
 





 
 
 






#line 98 "..\\..\\Library\\StdDriver\\inc\\gpio.h"















 
#line 333 "..\\..\\Library\\StdDriver\\inc\\gpio.h"

   




 














 















 














 















 















 















 















 
















 

































 











 












 











 


















 















 



void GPIO_SetMode(GPIO_T *port, uint32_t u32PinMask, uint32_t u32Mode);
void GPIO_EnableInt(GPIO_T *port, uint32_t u32Pin, uint32_t u32IntAttribs);
void GPIO_DisableInt(GPIO_T *port, uint32_t u32Pin);
void GPIO_SetSlewCtl(GPIO_T *port, uint32_t u32PinMask, uint32_t u32Mode);
void GPIO_SetPullCtl(GPIO_T *port, uint32_t u32PinMask, uint32_t u32Mode);


   

   

   






#line 647 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 1 "..\\..\\Library\\StdDriver\\inc\\ecap.h"
 





 











 



 



 





 
 
 
#line 42 "..\\..\\Library\\StdDriver\\inc\\ecap.h"







 
 
 




#line 64 "..\\..\\Library\\StdDriver\\inc\\ecap.h"






   



 














 








 















 












 












 















 












 












 








 








 








 








 








 








 












 
#line 257 "..\\..\\Library\\StdDriver\\inc\\ecap.h"







 








 








 








 
















 













 

















 













 








 














 














 









 








 












 









 


void ECAP_Open(ECAP_T* ecap, uint32_t u32FuncMask);
void ECAP_Close(ECAP_T* ecap);
void ECAP_EnableINT(ECAP_T* ecap, uint32_t u32Mask);
void ECAP_DisableINT(ECAP_T* ecap, uint32_t u32Mask);
   

   

   







#line 648 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 1 "..\\..\\Library\\StdDriver\\inc\\qei.h"
 





 











 



 



 

 
 
 





 
 
 
#line 46 "..\\..\\Library\\StdDriver\\inc\\qei.h"




   




 







 








 








 








 








 








 












 












 












 












 













 













 








 















 








 









 








 








 









 















 














 









 









 














 














 









 













 



void QEI_Close(QEI_T* qei);
void QEI_DisableInt(QEI_T* qei, uint32_t u32IntSel);
void QEI_EnableInt(QEI_T* qei, uint32_t u32IntSel);
void QEI_Open(QEI_T* qei, uint32_t u32Mode, uint32_t u32Value);
void QEI_Start(QEI_T* qei);
void QEI_Stop(QEI_T* qei);


   

   

   







#line 649 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 1 "..\\..\\Library\\StdDriver\\inc\\timer.h"
 





 











 



 



 
 
 
 
#line 37 "..\\..\\Library\\StdDriver\\inc\\timer.h"






#line 49 "..\\..\\Library\\StdDriver\\inc\\timer.h"

#line 56 "..\\..\\Library\\StdDriver\\inc\\timer.h"

   




 














 













 












 














 














 


 
static __inline void TIMER_Start(TIMER_T *timer);
static __inline void TIMER_Stop(TIMER_T *timer);
static __inline void TIMER_EnableWakeup(TIMER_T *timer);
static __inline void TIMER_DisableWakeup(TIMER_T *timer);
static __inline void TIMER_StartCapture(TIMER_T *timer);
static __inline void TIMER_StopCapture(TIMER_T *timer);
static __inline void TIMER_EnableCaptureDebounce(TIMER_T *timer);
static __inline void TIMER_DisableCaptureDebounce(TIMER_T *timer);
static __inline void TIMER_EnableEventCounterDebounce(TIMER_T *timer);
static __inline void TIMER_DisableEventCounterDebounce(TIMER_T *timer);
static __inline void TIMER_EnableInt(TIMER_T *timer);
static __inline void TIMER_DisableInt(TIMER_T *timer);
static __inline void TIMER_EnableCaptureInt(TIMER_T *timer);
static __inline void TIMER_DisableCaptureInt(TIMER_T *timer);
static __inline uint32_t TIMER_GetIntFlag(TIMER_T *timer);
static __inline void TIMER_ClearIntFlag(TIMER_T *timer);
static __inline uint32_t TIMER_GetCaptureIntFlag(TIMER_T *timer);
static __inline void TIMER_ClearCaptureIntFlag(TIMER_T *timer);
static __inline uint32_t TIMER_GetWakeupFlag(TIMER_T *timer);
static __inline void TIMER_ClearWakeupFlag(TIMER_T *timer);
static __inline uint32_t TIMER_GetCaptureData(TIMER_T *timer);
static __inline uint32_t TIMER_GetCounter(TIMER_T *timer);
static __inline void TIMER_ResetCounter(TIMER_T *timer);









 
static __inline void TIMER_Start(TIMER_T *timer)
{
    timer->CTL |= (0x1ul << (30));
}









 
static __inline void TIMER_Stop(TIMER_T *timer)
{
    timer->CTL &= ~(0x1ul << (30));
}











 
static __inline void TIMER_EnableWakeup(TIMER_T *timer)
{
    timer->CTL |= (0x1ul << (23));
}









 
static __inline void TIMER_DisableWakeup(TIMER_T *timer)
{
    timer->CTL &= ~(0x1ul << (23));
}









 
static __inline void TIMER_StartCapture(TIMER_T *timer)
{
    timer->EXTCTL |= (0x1ul << (3));
}









 
static __inline void TIMER_StopCapture(TIMER_T *timer)
{
    timer->EXTCTL &= ~(0x1ul << (3));
}









 
static __inline void TIMER_EnableCaptureDebounce(TIMER_T *timer)
{
    timer->EXTCTL |= (0x1ul << (6));
}









 
static __inline void TIMER_DisableCaptureDebounce(TIMER_T *timer)
{
    timer->EXTCTL &= ~(0x1ul << (6));
}









 
static __inline void TIMER_EnableEventCounterDebounce(TIMER_T *timer)
{
    timer->EXTCTL |= (0x1ul << (7));
}









 
static __inline void TIMER_DisableEventCounterDebounce(TIMER_T *timer)
{
    timer->EXTCTL &= ~(0x1ul << (7));
}









 
static __inline void TIMER_EnableInt(TIMER_T *timer)
{
    timer->CTL |= (0x1ul << (29));
}









 
static __inline void TIMER_DisableInt(TIMER_T *timer)
{
    timer->CTL &= ~(0x1ul << (29));
}









 
static __inline void TIMER_EnableCaptureInt(TIMER_T *timer)
{
    timer->EXTCTL |= (0x1ul << (5));
}









 
static __inline void TIMER_DisableCaptureInt(TIMER_T *timer)
{
    timer->EXTCTL &= ~(0x1ul << (5));
}










 
static __inline uint32_t TIMER_GetIntFlag(TIMER_T *timer)
{
    return ((timer->INTSTS & (0x1ul << (0))) ? 1UL : 0UL);
}









 
static __inline void TIMER_ClearIntFlag(TIMER_T *timer)
{
    timer->INTSTS = (0x1ul << (0));
}










 
static __inline uint32_t TIMER_GetCaptureIntFlag(TIMER_T *timer)
{
    return timer->EINTSTS;
}









 
static __inline void TIMER_ClearCaptureIntFlag(TIMER_T *timer)
{
    timer->EINTSTS = (0x1ul << (0));
}










 
static __inline uint32_t TIMER_GetWakeupFlag(TIMER_T *timer)
{
    return (timer->INTSTS & (0x1ul << (1)) ? 1UL : 0UL);
}









 
static __inline void TIMER_ClearWakeupFlag(TIMER_T *timer)
{
    timer->INTSTS = (0x1ul << (1));
}









 
static __inline uint32_t TIMER_GetCaptureData(TIMER_T *timer)
{
    return timer->CAP;
}









 
static __inline uint32_t TIMER_GetCounter(TIMER_T *timer)
{
    return timer->CNT;
}









 
static __inline void TIMER_ResetCounter(TIMER_T *timer)
{
    timer->CNT = 0UL;
    while((timer->CNT&(0x1ul << (31))) == (0x1ul << (31)))
    {
        ;
    }
}


uint32_t TIMER_Open(TIMER_T *timer, uint32_t u32Mode, uint32_t u32Freq);
void TIMER_Close(TIMER_T *timer);
void TIMER_Delay(TIMER_T *timer, uint32_t u32Usec);
void TIMER_EnableCapture(TIMER_T *timer, uint32_t u32CapMode, uint32_t u32Edge);
void TIMER_DisableCapture(TIMER_T *timer);
void TIMER_EnableEventCounter(TIMER_T *timer, uint32_t u32Edge);
void TIMER_DisableEventCounter(TIMER_T *timer);
uint32_t TIMER_GetModuleClock(TIMER_T *timer);
void TIMER_EnableFreqCounter(TIMER_T *timer,
                             uint32_t u32DropCount,
                             uint32_t u32Timeout,
                             uint32_t u32EnableInt);
void TIMER_DisableFreqCounter(TIMER_T *timer);
void TIMER_SetTriggerSource(TIMER_T *timer, uint32_t u32Src);
void TIMER_SetTriggerTarget(TIMER_T *timer, uint32_t u32Mask);

   

   

   








#line 650 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 1 "..\\..\\Library\\StdDriver\\inc\\timer_pwm.h"
 





 












 


 



 
 
 
 



 
 
 




 
 
 



 
 
 





 
 
 






 
 
 
#line 74 "..\\..\\Library\\StdDriver\\inc\\timer_pwm.h"


#line 83 "..\\..\\Library\\StdDriver\\inc\\timer_pwm.h"




 
 
 




 
 
 
#line 105 "..\\..\\Library\\StdDriver\\inc\\timer_pwm.h"

 
 
 





 
 
 






 
 
 






   




 











 












 











 











 















 











 











 














 











 













 











 













 











 











 















 
















 
















 


















 




















 













 











 











 












 











 











 











 












 











 











 











 












 











 











 











 












 











 












 











 












 











 












 











 
















 



void TPWM_SetCounterClockSource(TIMER_T *timer, uint32_t u32CntClkSrc);
uint32_t TPWM_ConfigOutputFreqAndDuty(TIMER_T *timer, uint32_t u32Frequency, uint32_t u32DutyCycle);
void TPWM_EnableDeadTime(TIMER_T *timer, uint32_t u32DTCount);
void TPWM_EnableDeadTimeWithPrescale(TIMER_T *timer, uint32_t u32DTCount);
void TPWM_DisableDeadTime(TIMER_T *timer);
void TPWM_EnableCounter(TIMER_T *timer);
void TPWM_DisableCounter(TIMER_T *timer);
void TPWM_EnableTriggerADC(TIMER_T *timer, uint32_t u32Condition);
void TPWM_DisableTriggerADC(TIMER_T *timer);
void TPWM_EnableFaultBrake(TIMER_T *timer, uint32_t u32CH0Level, uint32_t u32CH1Level, uint32_t u32BrakeSource);
void TPWM_EnableFaultBrakeInt(TIMER_T *timer, uint32_t u32IntSource);
void TPWM_DisableFaultBrakeInt(TIMER_T *timer, uint32_t u32IntSource);
uint32_t TPWM_GetFaultBrakeIntFlag(TIMER_T *timer, uint32_t u32IntSource);
void TPWM_ClearFaultBrakeIntFlag(TIMER_T *timer, uint32_t u32IntSource);
void TPWM_SetLoadMode(TIMER_T *timer, uint32_t u32LoadMode);
void TPWM_EnableBrakePinDebounce(TIMER_T *timer, uint32_t u32BrakePinSrc, uint32_t u32DebounceCnt, uint32_t u32ClkSrcSel);
void TPWM_DisableBrakePinDebounce(TIMER_T *timer);
void TPWM_EnableBrakePinInverse(TIMER_T *timer);
void TPWM_DisableBrakePinInverse(TIMER_T *timer);
void TPWM_SetBrakePinSource(TIMER_T *timer, uint32_t u32BrakePinNum);

   

   

   







#line 651 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 1 "..\\..\\Library\\StdDriver\\inc\\pdma.h"
 





 











 



 



 


 
 
 




 
 
 




 
 
 





 
 
 



#line 66 "..\\..\\Library\\StdDriver\\inc\\pdma.h"

 
 
 



 
 
 
#line 179 "..\\..\\Library\\StdDriver\\inc\\pdma.h"
 
 
 





   



 










 











 













 











 













 











 












 












 













 













 













 













 













 













 













 


 
 
 
void PDMA_Open(PDMA_T * pdma,uint32_t u32Mask);
void PDMA_Close(PDMA_T * pdma);
void PDMA_SetTransferCnt(PDMA_T * pdma,uint32_t u32Ch, uint32_t u32Width, uint32_t u32TransCount);
void PDMA_SetTransferAddr(PDMA_T * pdma,uint32_t u32Ch, uint32_t u32SrcAddr, uint32_t u32SrcCtrl, uint32_t u32DstAddr, uint32_t u32DstCtrl);
void PDMA_SetTransferMode(PDMA_T * pdma,uint32_t u32Ch, uint32_t u32Peripheral, uint32_t u32ScatterEn, uint32_t u32DescAddr);
void PDMA_SetBurstType(PDMA_T * pdma,uint32_t u32Ch, uint32_t u32BurstType, uint32_t u32BurstSize);
void PDMA_EnableTimeout(PDMA_T * pdma,uint32_t u32Mask);
void PDMA_DisableTimeout(PDMA_T * pdma,uint32_t u32Mask);
void PDMA_SetTimeOut(PDMA_T * pdma,uint32_t u32Ch, uint32_t u32OnOff, uint32_t u32TimeOutCnt);
void PDMA_Trigger(PDMA_T * pdma,uint32_t u32Ch);
void PDMA_EnableInt(PDMA_T * pdma,uint32_t u32Ch, uint32_t u32Mask);
void PDMA_DisableInt(PDMA_T * pdma,uint32_t u32Ch, uint32_t u32Mask);
void PDMA_SetStride(PDMA_T * pdma,uint32_t u32Ch, uint32_t u32DestLen, uint32_t u32SrcLen, uint32_t u32TransCount);
void PDMA_SetRepeat(PDMA_T * pdma,uint32_t u32Ch, uint32_t u32DestInterval, uint32_t u32SrcInterval, uint32_t u32RepeatCount);


   

   

   







#line 652 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 1 "..\\..\\Library\\StdDriver\\inc\\i2c.h"
 





 











 



 



 

 
 
 
#line 41 "..\\..\\Library\\StdDriver\\inc\\i2c.h"

 
 
 



   



 










 











 











 











 












 











 












 












 











 








 








 








 








 








 








 








 


 
 
 

 
static __inline void I2C_STOP(I2C_T *i2c);









 
static __inline void I2C_STOP(I2C_T *i2c)
{

    (i2c)->CTL0 |= ((0x1ul << (3)) | (0x1ul << (4)));
    while(i2c->CTL0 & (0x1ul << (4)))
    {
    }
}

void I2C_ClearTimeoutFlag(I2C_T *i2c);
void I2C_Close(I2C_T *i2c);
void I2C_Trigger(I2C_T *i2c, uint8_t u8Start, uint8_t u8Stop, uint8_t u8Si, uint8_t u8Ack);
void I2C_DisableInt(I2C_T *i2c);
void I2C_EnableInt(I2C_T *i2c);
uint32_t I2C_GetBusClockFreq(I2C_T *i2c);
uint32_t I2C_GetIntFlag(I2C_T *i2c);
uint32_t I2C_GetStatus(I2C_T *i2c);
uint32_t I2C_Open(I2C_T *i2c, uint32_t u32BusClock);
uint8_t I2C_GetData(I2C_T *i2c);
void I2C_SetSlaveAddr(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddr, uint8_t u8GCMode);
void I2C_SetSlaveAddrMask(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddrMask);
uint32_t I2C_SetBusClockFreq(I2C_T *i2c, uint32_t u32BusClock);
void I2C_EnableTimeout(I2C_T *i2c, uint8_t u8LongTimeout);
void I2C_DisableTimeout(I2C_T *i2c);
void I2C_EnableWakeup(I2C_T *i2c);
void I2C_DisableWakeup(I2C_T *i2c);
void I2C_SetData(I2C_T *i2c, uint8_t u8Data);
uint8_t I2C_WriteByte(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t data);
uint32_t I2C_WriteMultiBytes(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t data[], uint32_t u32wLen);
uint8_t I2C_WriteByteOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr, uint8_t data);
uint32_t I2C_WriteMultiBytesOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr, uint8_t data[], uint32_t u32wLen);
uint8_t I2C_WriteByteTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr, uint8_t data);
uint32_t I2C_WriteMultiBytesTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr, uint8_t data[], uint32_t u32wLen);
uint8_t I2C_ReadByte(I2C_T *i2c, uint8_t u8SlaveAddr);
uint32_t I2C_ReadMultiBytes(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t rdata[], uint32_t u32rLen);
uint8_t I2C_ReadByteOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr);
uint32_t I2C_ReadMultiBytesOneReg(I2C_T *i2c, uint8_t u8SlaveAddr, uint8_t u8DataAddr, uint8_t rdata[], uint32_t u32rLen);
uint8_t I2C_ReadByteTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr);
uint32_t I2C_ReadMultiBytesTwoRegs(I2C_T *i2c, uint8_t u8SlaveAddr, uint16_t u16DataAddr, uint8_t rdata[], uint32_t u32rLen);

   

   

   








#line 653 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 1 "..\\..\\Library\\StdDriver\\inc\\i2s.h"
 





 










 



 



 





 



 
#line 43 "..\\..\\Library\\StdDriver\\inc\\i2s.h"

 



 





 





 



 



 
#line 85 "..\\..\\Library\\StdDriver\\inc\\i2s.h"

#line 102 "..\\..\\Library\\StdDriver\\inc\\i2s.h"

 



 



   



 
 
 
 






 
static __inline void I2S_ENABLE_TX_ZCD(I2S_T *i2s, uint32_t u32ChMask)
{
    if((u32ChMask > 0U) && (u32ChMask < 9U))
    {
        i2s->CTL1 |= ((uint32_t)1U << (u32ChMask-1U));
    }
}







 
static __inline void I2S_DISABLE_TX_ZCD(I2S_T *i2s, uint32_t u32ChMask)
{
    if((u32ChMask > 0U) && (u32ChMask < 9U))
    {
        i2s->CTL1 &= ~((uint32_t)1U << (u32ChMask-1U));
    }
}






 







 







 







 







 







 







 







 







 







 







 







 










 
static __inline void I2S_SET_MONO_RX_CHANNEL(I2S_T *i2s, uint32_t u32Ch)
{
    u32Ch == (0x1ul << (23)) ?
    (i2s->CTL0 |= (0x1ul << (23))) :
    (i2s->CTL0 &= ~(0x1ul << (23)));
}







 







 








 








 








 








 







 







 


void I2S_Close(I2S_T *i2s);
void I2S_EnableInt(I2S_T *i2s, uint32_t u32Mask);
void I2S_DisableInt(I2S_T *i2s, uint32_t u32Mask);
uint32_t I2S_EnableMCLK(I2S_T *i2s, uint32_t u32BusClock);
void I2S_DisableMCLK(I2S_T *i2s);
void I2S_SetFIFO(I2S_T *i2s, uint32_t u32TxThreshold, uint32_t u32RxThreshold);
void I2S_ConfigureTDM(I2S_T *i2s, uint32_t u32ChannelWidth, uint32_t u32ChannelNum, uint32_t u32SyncWidth);
uint32_t I2S_Open(I2S_T *i2s, uint32_t u32MasterSlave, uint32_t u32SampleRate, uint32_t u32WordWidth, uint32_t u32MonoData, uint32_t u32DataFormat);

   


   

   







#line 654 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 1 "..\\..\\Library\\StdDriver\\inc\\epwm.h"
 





 











 



 



 
#line 35 "..\\..\\Library\\StdDriver\\inc\\epwm.h"

 
 
 




 
 
 



 
 
 





 
 
 





 
 
 
#line 84 "..\\..\\Library\\StdDriver\\inc\\epwm.h"






 
 
 
#line 102 "..\\..\\Library\\StdDriver\\inc\\epwm.h"

#line 112 "..\\..\\Library\\StdDriver\\inc\\epwm.h"




 
 
 
#line 129 "..\\..\\Library\\StdDriver\\inc\\epwm.h"

 
 
 







 
 
 



 
 
 





 
 
 




 
 
 
#line 170 "..\\..\\Library\\StdDriver\\inc\\epwm.h"

 
 
 
#line 182 "..\\..\\Library\\StdDriver\\inc\\epwm.h"

 
 
 






 
 
 






   




 







 








 








 








 















 










 
#line 277 "..\\..\\Library\\StdDriver\\inc\\epwm.h"








 










 









 









 












 
















 











 











 









 











 












 









 













 
#line 438 "..\\..\\Library\\StdDriver\\inc\\epwm.h"









 










 










 






























 
#line 513 "..\\..\\Library\\StdDriver\\inc\\epwm.h"












 











 




 
 
 
uint32_t EPWM_ConfigCaptureChannel(EPWM_T *epwm, uint32_t u32ChannelNum, uint32_t u32UnitTimeNsec, uint32_t u32CaptureEdge);
uint32_t EPWM_ConfigOutputChannel(EPWM_T *epwm, uint32_t u32ChannelNum, uint32_t u32Frequency, uint32_t u32DutyCycle);
void EPWM_Start(EPWM_T *epwm, uint32_t u32ChannelMask);
void EPWM_Stop(EPWM_T *epwm, uint32_t u32ChannelMask);
void EPWM_ForceStop(EPWM_T *epwm, uint32_t u32ChannelMask);
void EPWM_EnableADCTrigger(EPWM_T *epwm, uint32_t u32ChannelNum, uint32_t u32Condition);
void EPWM_DisableADCTrigger(EPWM_T *epwm, uint32_t u32ChannelNum);
int32_t EPWM_EnableADCTriggerPrescale(EPWM_T *epwm, uint32_t u32ChannelNum, uint32_t u32Prescale, uint32_t u32PrescaleCnt);
void EPWM_DisableADCTriggerPrescale(EPWM_T *epwm, uint32_t u32ChannelNum);
void EPWM_ClearADCTriggerFlag(EPWM_T *epwm, uint32_t u32ChannelNum, uint32_t u32Condition);
uint32_t EPWM_GetADCTriggerFlag(EPWM_T *epwm, uint32_t u32ChannelNum);
void EPWM_EnableDACTrigger(EPWM_T *epwm, uint32_t u32ChannelNum, uint32_t u32Condition);
void EPWM_DisableDACTrigger(EPWM_T *epwm, uint32_t u32ChannelNum);
void EPWM_ClearDACTriggerFlag(EPWM_T *epwm, uint32_t u32ChannelNum, uint32_t u32Condition);
uint32_t EPWM_GetDACTriggerFlag(EPWM_T *epwm, uint32_t u32ChannelNum);
void EPWM_EnableFaultBrake(EPWM_T *epwm, uint32_t u32ChannelMask, uint32_t u32LevelMask, uint32_t u32BrakeSource);
void EPWM_EnableCapture(EPWM_T *epwm, uint32_t u32ChannelMask);
void EPWM_DisableCapture(EPWM_T *epwm, uint32_t u32ChannelMask);
void EPWM_EnableOutput(EPWM_T *epwm, uint32_t u32ChannelMask);
void EPWM_DisableOutput(EPWM_T *epwm, uint32_t u32ChannelMask);
void EPWM_EnablePDMA(EPWM_T *epwm, uint32_t u32ChannelNum, uint32_t u32RisingFirst, uint32_t u32Mode);
void EPWM_DisablePDMA(EPWM_T *epwm, uint32_t u32ChannelNum);
void EPWM_EnableDeadZone(EPWM_T *epwm, uint32_t u32ChannelNum, uint32_t u32Duration);
void EPWM_DisableDeadZone(EPWM_T *epwm, uint32_t u32ChannelNum);
void EPWM_EnableCaptureInt(EPWM_T *epwm, uint32_t u32ChannelNum, uint32_t u32Edge);
void EPWM_DisableCaptureInt(EPWM_T *epwm, uint32_t u32ChannelNum, uint32_t u32Edge);
void EPWM_ClearCaptureIntFlag(EPWM_T *epwm, uint32_t u32ChannelNum, uint32_t u32Edge);
uint32_t EPWM_GetCaptureIntFlag(EPWM_T *epwm, uint32_t u32ChannelNum);
void EPWM_EnableDutyInt(EPWM_T *epwm, uint32_t u32ChannelNum, uint32_t u32IntDutyType);
void EPWM_DisableDutyInt(EPWM_T *epwm, uint32_t u32ChannelNum);
void EPWM_ClearDutyIntFlag(EPWM_T *epwm, uint32_t u32ChannelNum);
uint32_t EPWM_GetDutyIntFlag(EPWM_T *epwm, uint32_t u32ChannelNum);
void EPWM_EnableFaultBrakeInt(EPWM_T *epwm, uint32_t u32BrakeSource);
void EPWM_DisableFaultBrakeInt(EPWM_T *epwm, uint32_t u32BrakeSource);
void EPWM_ClearFaultBrakeIntFlag(EPWM_T *epwm, uint32_t u32BrakeSource);
uint32_t EPWM_GetFaultBrakeIntFlag(EPWM_T *epwm, uint32_t u32BrakeSource);
void EPWM_EnablePeriodInt(EPWM_T *epwm, uint32_t u32ChannelNum,  uint32_t u32IntPeriodType);
void EPWM_DisablePeriodInt(EPWM_T *epwm, uint32_t u32ChannelNum);
void EPWM_ClearPeriodIntFlag(EPWM_T *epwm, uint32_t u32ChannelNum);
uint32_t EPWM_GetPeriodIntFlag(EPWM_T *epwm, uint32_t u32ChannelNum);
void EPWM_EnableZeroInt(EPWM_T *epwm, uint32_t u32ChannelNum);
void EPWM_DisableZeroInt(EPWM_T *epwm, uint32_t u32ChannelNum);
void EPWM_ClearZeroIntFlag(EPWM_T *epwm, uint32_t u32ChannelNum);
uint32_t EPWM_GetZeroIntFlag(EPWM_T *epwm, uint32_t u32ChannelNum);
void EPWM_EnableAcc(EPWM_T *epwm, uint32_t u32ChannelNum, uint32_t u32IntFlagCnt, uint32_t u32IntAccSrc);
void EPWM_DisableAcc(EPWM_T *epwm, uint32_t u32ChannelNum);
void EPWM_EnableAccInt(EPWM_T *epwm, uint32_t u32ChannelNum);
void EPWM_DisableAccInt(EPWM_T *epwm, uint32_t u32ChannelNum);
void EPWM_ClearAccInt(EPWM_T *epwm, uint32_t u32ChannelNum);
uint32_t EPWM_GetAccInt(EPWM_T *epwm, uint32_t u32ChannelNum);
void EPWM_EnableAccPDMA(EPWM_T *epwm, uint32_t u32ChannelNum);
void EPWM_DisableAccPDMA(EPWM_T *epwm, uint32_t u32ChannelNum);
void EPWM_EnableAccStopMode(EPWM_T *epwm, uint32_t u32ChannelNum);
void EPWM_DisableAccStopMode(EPWM_T *epwm, uint32_t u32ChannelNum);
void EPWM_ClearFTDutyIntFlag(EPWM_T *epwm, uint32_t u32ChannelNum);
uint32_t EPWM_GetFTDutyIntFlag(EPWM_T *epwm, uint32_t u32ChannelNum);
void EPWM_EnableLoadMode(EPWM_T *epwm, uint32_t u32ChannelNum, uint32_t u32LoadMode);
void EPWM_DisableLoadMode(EPWM_T *epwm, uint32_t u32ChannelNum, uint32_t u32LoadMode);
void EPWM_ConfigSyncPhase(EPWM_T *epwm, uint32_t u32ChannelNum, uint32_t u32SyncSrc, uint32_t u32Direction, uint32_t u32StartPhase);
void EPWM_EnableSyncPhase(EPWM_T *epwm, uint32_t u32ChannelMask);
void EPWM_DisableSyncPhase(EPWM_T *epwm, uint32_t u32ChannelMask);
void EPWM_EnableSyncNoiseFilter(EPWM_T *epwm, uint32_t u32ClkCnt, uint32_t u32ClkDivSel);
void EPWM_DisableSyncNoiseFilter(EPWM_T *epwm);
void EPWM_EnableSyncPinInverse(EPWM_T *epwm);
void EPWM_DisableSyncPinInverse(EPWM_T *epwm);
void EPWM_SetClockSource(EPWM_T *epwm, uint32_t u32ChannelNum, uint32_t u32ClkSrcSel);
void EPWM_EnableBrakeNoiseFilter(EPWM_T *epwm, uint32_t u32BrakePinNum, uint32_t u32ClkCnt, uint32_t u32ClkDivSel);
void EPWM_DisableBrakeNoiseFilter(EPWM_T *epwm, uint32_t u32BrakePinNum);
void EPWM_EnableBrakePinInverse(EPWM_T *epwm, uint32_t u32BrakePinNum);
void EPWM_DisableBrakePinInverse(EPWM_T *epwm, uint32_t u32BrakePinNum);
void EPWM_SetBrakePinSource(EPWM_T *epwm, uint32_t u32BrakePinNum, uint32_t u32SelAnotherModule);
void EPWM_SetLeadingEdgeBlanking(EPWM_T *epwm, uint32_t u32TrigSrcSel, uint32_t u32TrigType, uint32_t u32BlankingCnt, uint32_t u32BlankingEnable);
uint32_t EPWM_GetWrapAroundFlag(EPWM_T *epwm, uint32_t u32ChannelNum);
void EPWM_ClearWrapAroundFlag(EPWM_T *epwm, uint32_t u32ChannelNum);
void EPWM_EnableFaultDetect(EPWM_T *epwm, uint32_t u32ChannelNum, uint32_t u32AfterPrescaler, uint32_t u32ClkSel);
void EPWM_DisableFaultDetect(EPWM_T *epwm, uint32_t u32ChannelNum);
void EPWM_EnableFaultDetectOutput(EPWM_T *epwm, uint32_t u32ChannelNum);
void EPWM_DisableFaultDetectOutput(EPWM_T *epwm, uint32_t u32ChannelNum);
void EPWM_EnableFaultDetectDeglitch(EPWM_T *epwm, uint32_t u32ChannelNum, uint32_t u32DeglitchSmpCycle);
void EPWM_DisableFaultDetectDeglitch(EPWM_T *epwm, uint32_t u32ChannelNum);
void EPWM_EnableFaultDetectMask(EPWM_T *epwm, uint32_t u32ChannelNum, uint32_t u32MaskCnt);
void EPWM_DisableFaultDetectMask(EPWM_T *epwm, uint32_t u32ChannelNum);
void EPWM_EnableFaultDetectInt(EPWM_T *epwm, uint32_t u32ChannelNum);
void EPWM_DisableFaultDetectInt(EPWM_T *epwm, uint32_t u32ChannelNum);
void EPWM_ClearFaultDetectInt(EPWM_T *epwm, uint32_t u32ChannelNum);
uint32_t EPWM_GetFaultDetectInt(EPWM_T *epwm, uint32_t u32ChannelNum);

   

   

   







#line 655 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 1 "..\\..\\Library\\StdDriver\\inc\\eadc.h"
 





 











 



 



 

 
 
 






 
 
 




#line 81 "..\\..\\Library\\StdDriver\\inc\\eadc.h"







 
 
 
#line 97 "..\\..\\Library\\StdDriver\\inc\\eadc.h"

   



 
 
 
 







 










 








 











 










 










 









 









 









 











 










 











 











 











 











 











 









 









 









 









 









 











 









 











 










 









 









 









 









 









 
















 
#line 453 "..\\..\\Library\\StdDriver\\inc\\eadc.h"















 
#line 479 "..\\..\\Library\\StdDriver\\inc\\eadc.h"















 
#line 505 "..\\..\\Library\\StdDriver\\inc\\eadc.h"















 
#line 531 "..\\..\\Library\\StdDriver\\inc\\eadc.h"








 









 











 









 








 








 








 








 


 
 
 
void EADC_Open(EADC_T *eadc, uint32_t u32InputMode);
void EADC_Close(EADC_T *eadc);
void EADC_ConfigSampleModule(EADC_T *eadc, uint32_t u32ModuleNum, uint32_t u32TriggerSrc, uint32_t u32Channel);
void EADC_SetTriggerDelayTime(EADC_T *eadc, uint32_t u32ModuleNum, uint32_t u32TriggerDelayTime, uint32_t u32DelayClockDivider);
void EADC_SetExtendSampleTime(EADC_T *eadc, uint32_t u32ModuleNum, uint32_t u32ExtendSampleTime);

   

   

   







#line 656 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 1 "..\\..\\Library\\StdDriver\\inc\\adc.h"
 





 











 



 



 

#line 42 "..\\..\\Library\\StdDriver\\inc\\adc.h"





   




 







 







 







 







 







 








 








 








 







 











 
#line 149 "..\\..\\Library\\StdDriver\\inc\\adc.h"






 










 







 








 




void ADC_Open(ADC_T *adc,
              uint32_t u32InputMode,
              uint32_t u32OpMode,
              uint32_t u32ChMask);
void ADC_Close(ADC_T *adc);
void ADC_EnableInt(ADC_T *adc, uint32_t u32Mask);
void ADC_DisableInt(ADC_T *adc, uint32_t u32Mask);



   

   

   







#line 657 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 1 "..\\..\\Library\\StdDriver\\inc\\wdt.h"
 





 











 



 



 
 
 
 
#line 39 "..\\..\\Library\\StdDriver\\inc\\wdt.h"

 
 
 





 
 
 


   




 










 











 











 












 












 












 














 


 
static __inline void WDT_Close(void);
static __inline void WDT_EnableInt(void);
static __inline void WDT_DisableInt(void);









 
static __inline void WDT_Close(void)
{
    ((WDT_T *) (0x40980000UL))->CTL = 0UL;
    return;
}









 
static __inline void WDT_EnableInt(void)
{
    ((WDT_T *) (0x40980000UL))->CTL |= (0x1ul << (6));
    return;
}









 
static __inline void WDT_DisableInt(void)
{
     
    ((WDT_T *) (0x40980000UL))->CTL &= ~((0x1ul << (6)) | (0x1ul << (2)) | (0x1ul << (3)) | (0x1ul << (5)));
    return;
}

void WDT_Open(uint32_t u32TimeoutInterval, uint32_t u32ResetDelay, uint32_t u32EnableReset, uint32_t u32EnableWakeup);

   

   

   







#line 658 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 1 "..\\..\\Library\\StdDriver\\inc\\wwdt.h"
 





 











 



 



 
 
 
 
#line 47 "..\\..\\Library\\StdDriver\\inc\\wwdt.h"

 
 
 


   




 










 











 












 












 











 














 


void WWDT_Open(uint32_t u32PreScale, uint32_t u32CmpValue, uint32_t u32EnableInt);

   

   

   







#line 659 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 1 "..\\..\\Library\\StdDriver\\inc\\ebi.h"
 





 











 



 



 
 
 
 





 
 
 




 
 
 



 
 
 



 
 
 
#line 66 "..\\..\\Library\\StdDriver\\inc\\ebi.h"

#line 74 "..\\..\\Library\\StdDriver\\inc\\ebi.h"





   




 










 












 











 












 











 












 











 












 











 












 











 












 











 












 











 












 











 












 











 











 


void EBI_Open(uint32_t u32Bank, uint32_t u32DataWidth, uint32_t u32TimingClass, uint32_t u32BusMode, uint32_t u32CSActiveLevel);
void EBI_Close(uint32_t u32Bank);
void EBI_SetBusTiming(uint32_t u32Bank, uint32_t u32TimingConfig, uint32_t u32MclkDiv);

   

   

   







#line 660 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 1 "..\\..\\Library\\StdDriver\\inc\\scuart.h"
 





 











 



 



 













   




 

 






 









 









 








 









 









 









 


 






 









 










 










 









 


 











 












 














 











 










 











 


void SCUART_Close(SC_T* sc);
uint32_t SCUART_Open(SC_T* sc, uint32_t u32baudrate);
uint32_t SCUART_Read(SC_T* sc, uint8_t pu8RxBuf[], uint32_t u32ReadBytes);
uint32_t SCUART_SetLineConfig(SC_T* sc, uint32_t u32Baudrate, uint32_t u32DataWidth, uint32_t u32Parity, uint32_t  u32StopBits);
void SCUART_SetTimeoutCnt(SC_T* sc, uint32_t u32TOC);
void SCUART_Write(SC_T* sc,uint8_t pu8TxBuf[], uint32_t u32WriteBytes);

   

   

   







#line 661 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 1 "..\\..\\Library\\StdDriver\\inc\\sc.h"
 





 











 



 



 
#line 34 "..\\..\\Library\\StdDriver\\inc\\sc.h"

#line 45 "..\\..\\Library\\StdDriver\\inc\\sc.h"


   




 


















 



















 








 
#line 109 "..\\..\\Library\\StdDriver\\inc\\sc.h"








 
#line 126 "..\\..\\Library\\StdDriver\\inc\\sc.h"







 
#line 142 "..\\..\\Library\\StdDriver\\inc\\sc.h"







 
#line 158 "..\\..\\Library\\StdDriver\\inc\\sc.h"






 








 









 


 
static __inline void SC_SetTxRetry(SC_T *sc, uint32_t u32Count);
static __inline void  SC_SetRxRetry(SC_T *sc, uint32_t u32Count);






 
static __inline void SC_SetTxRetry(SC_T *sc, uint32_t u32Count)
{
    while((sc)->CTL & (0x1ul << (30)))
    {
        ;
    }
     
    (sc)->CTL &= ~((0x7ul << (20)) | (0x1ul << (23)));

    if((u32Count) != 0UL)
    {
        while((sc)->CTL & (0x1ul << (30)))
        {
            ;
        }
        (sc)->CTL |= (((u32Count) - 1UL) << (20)) | (0x1ul << (23));
    }
}






 
static __inline void  SC_SetRxRetry(SC_T *sc, uint32_t u32Count)
{
    while((sc)->CTL & (0x1ul << (30)))
    {
        ;
    }
     
    (sc)->CTL &= ~((0x7ul << (16)) | (0x1ul << (19)));

    if((u32Count) != 0UL)
    {
        while((sc)->CTL & (0x1ul << (30)))
        {
            ;
        }
        (sc)->CTL |= (((u32Count) - 1UL) << (16)) | (0x1ul << (19));
    }

}


uint32_t SC_IsCardInserted(SC_T *sc);
void SC_ClearFIFO(SC_T *sc);
void SC_Close(SC_T *sc);
void SC_Open(SC_T *sc, uint32_t u32CardDet, uint32_t u32PWR);
void SC_ResetReader(SC_T *sc);
void SC_SetBlockGuardTime(SC_T *sc, uint32_t u32BGT);
void SC_SetCharGuardTime(SC_T *sc, uint32_t u32CGT);
void SC_StopAllTimer(SC_T *sc);
void SC_StartTimer(SC_T *sc, uint32_t u32TimerNum, uint32_t u32Mode, uint32_t u32ETUCount);
void SC_StopTimer(SC_T *sc, uint32_t u32TimerNum);
uint32_t SC_GetInterfaceClock(SC_T *sc);


   

   

   







#line 662 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 1 "..\\..\\Library\\StdDriver\\inc\\spi.h"
 





 











 



 



 













 
#line 52 "..\\..\\Library\\StdDriver\\inc\\spi.h"

 
#line 62 "..\\..\\Library\\StdDriver\\inc\\spi.h"


 





 



 





 



 



 



 
#line 100 "..\\..\\Library\\StdDriver\\inc\\spi.h"

   




 







 








 








 








 








 








 








 








 









 









 









 








 









 








 








 








 








 










 








 








 









 









 








 








 


 
static __inline void SPII2S_ENABLE_TX_ZCD(SPI_T *i2s, uint32_t u32ChMask);
static __inline void SPII2S_DISABLE_TX_ZCD(SPI_T *i2s, uint32_t u32ChMask);
static __inline void SPII2S_SET_MONO_RX_CHANNEL(SPI_T *i2s, uint32_t u32Ch);









 
static __inline void SPII2S_ENABLE_TX_ZCD(SPI_T *i2s, uint32_t u32ChMask)
{
    if(u32ChMask == (0U))
    {
        i2s->I2SCTL |= (0x1ul << (16));
    }
    else
    {
        i2s->I2SCTL |= (0x1ul << (17));
    }
}









 
static __inline void SPII2S_DISABLE_TX_ZCD(SPI_T *i2s, uint32_t u32ChMask)
{
    if(u32ChMask == (0U))
    {
        i2s->I2SCTL &= ~(0x1ul << (16));
    }
    else
    {
        i2s->I2SCTL &= ~(0x1ul << (17));
    }
}







 








 








 








 








 








 








 








 








 








 








 








 











 
static __inline void SPII2S_SET_MONO_RX_CHANNEL(SPI_T *i2s, uint32_t u32Ch)
{
    u32Ch == (0x1ul << (23)) ?
    (i2s->I2SCTL |= (0x1ul << (23))) :
    (i2s->I2SCTL &= ~(0x1ul << (23)));
}








 








 









 










 








 








 




 
uint32_t SPI_Open(SPI_T *spi, uint32_t u32MasterSlave, uint32_t u32SPIMode, uint32_t u32DataWidth, uint32_t u32BusClock);
void SPI_Close(SPI_T *spi);
void SPI_ClearRxFIFO(SPI_T *spi);
void SPI_ClearTxFIFO(SPI_T *spi);
void SPI_DisableAutoSS(SPI_T *spi);
void SPI_EnableAutoSS(SPI_T *spi, uint32_t u32SSPinMask, uint32_t u32ActiveLevel);
uint32_t SPI_SetBusClock(SPI_T *spi, uint32_t u32BusClock);
void SPI_SetFIFO(SPI_T *spi, uint32_t u32TxThreshold, uint32_t u32RxThreshold);
uint32_t SPI_GetBusClock(SPI_T *spi);
void SPI_EnableInt(SPI_T *spi, uint32_t u32Mask);
void SPI_DisableInt(SPI_T *spi, uint32_t u32Mask);
uint32_t SPI_GetIntFlag(SPI_T *spi, uint32_t u32Mask);
void SPI_ClearIntFlag(SPI_T *spi, uint32_t u32Mask);
uint32_t SPI_GetStatus(SPI_T *spi, uint32_t u32Mask);

uint32_t SPII2S_Open(SPI_T *i2s, uint32_t u32MasterSlave, uint32_t u32SampleRate, uint32_t u32WordWidth, uint32_t u32Channels, uint32_t u32DataFormat);
void SPII2S_Close(SPI_T *i2s);
void SPII2S_EnableInt(SPI_T *i2s, uint32_t u32Mask);
void SPII2S_DisableInt(SPI_T *i2s, uint32_t u32Mask);
uint32_t SPII2S_EnableMCLK(SPI_T *i2s, uint32_t u32BusClock);
void SPII2S_DisableMCLK(SPI_T *i2s);
void SPII2S_SetFIFO(SPI_T *i2s, uint32_t u32TxThreshold, uint32_t u32RxThreshold);


   

   

   







#line 663 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 1 "..\\..\\Library\\StdDriver\\inc\\qspi.h"
 





 











 



 



 













 
#line 52 "..\\..\\Library\\StdDriver\\inc\\qspi.h"

 
#line 62 "..\\..\\Library\\StdDriver\\inc\\qspi.h"

   




 







 








 








 








 








 








 








 








 









 









 









 








 









 








 








 








 








 










 








 








 









 









 








 








 







 







 







 







 







 







 





 
uint32_t QSPI_Open(QSPI_T *qspi, uint32_t u32MasterSlave, uint32_t u32QSPIMode, uint32_t u32DataWidth, uint32_t u32BusClock);
void QSPI_Close(QSPI_T *qspi);
void QSPI_ClearRxFIFO(QSPI_T *qspi);
void QSPI_ClearTxFIFO(QSPI_T *qspi);
void QSPI_DisableAutoSS(QSPI_T *qspi);
void QSPI_EnableAutoSS(QSPI_T *qspi, uint32_t u32SSPinMask, uint32_t u32ActiveLevel);
uint32_t QSPI_SetBusClock(QSPI_T *qspi, uint32_t u32BusClock);
void QSPI_SetFIFO(QSPI_T *qspi, uint32_t u32TxThreshold, uint32_t u32RxThreshold);
uint32_t QSPI_GetBusClock(QSPI_T *qspi);
void QSPI_EnableInt(QSPI_T *qspi, uint32_t u32Mask);
void QSPI_DisableInt(QSPI_T *qspi, uint32_t u32Mask);
uint32_t QSPI_GetIntFlag(QSPI_T *qspi, uint32_t u32Mask);
void QSPI_ClearIntFlag(QSPI_T *qspi, uint32_t u32Mask);
uint32_t QSPI_GetStatus(QSPI_T *qspi, uint32_t u32Mask);


   

   

   







#line 664 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 1 "..\\..\\Library\\StdDriver\\inc\\rtc.h"
 





 











 



 



 
 
 
 


 
 
 





 
 
 
#line 52 "..\\..\\Library\\StdDriver\\inc\\rtc.h"

 
 
 
#line 63 "..\\..\\Library\\StdDriver\\inc\\rtc.h"

 
 
 



   




 


 
typedef struct
{
    uint32_t u32Year;            
    uint32_t u32Month;           
    uint32_t u32Day;             
    uint32_t u32DayOfWeek;       
    uint32_t u32Hour;            
    uint32_t u32Minute;          
    uint32_t u32Second;          
    uint32_t u32TimeScale;       
    uint32_t u32AmPm;            
} S_RTC_TIME_DATA_T;

   




 











 











 











 












 












 













 


void RTC_Open(S_RTC_TIME_DATA_T *sPt);
void RTC_GetDateAndTime(S_RTC_TIME_DATA_T *sPt);
void RTC_GetAlarmDateAndTime(S_RTC_TIME_DATA_T *sPt);
void RTC_SetDateAndTime(S_RTC_TIME_DATA_T *sPt);
void RTC_SetAlarmDateAndTime(S_RTC_TIME_DATA_T *sPt);
void RTC_SetDate(uint32_t u32Year, uint32_t u32Month, uint32_t u32Day, uint32_t u32DayOfWeek);
void RTC_SetTime(uint32_t u32Hour, uint32_t u32Minute, uint32_t u32Second, uint32_t u32TimeMode, uint32_t u32AmPm);
void RTC_SetAlarmDate(uint32_t u32Year, uint32_t u32Month, uint32_t u32Day);
void RTC_SetAlarmTime(uint32_t u32Hour, uint32_t u32Minute, uint32_t u32Second, uint32_t u32TimeMode, uint32_t u32AmPm);
void RTC_SetAlarmDateMask(uint8_t u8IsTenYMsk, uint8_t u8IsYMsk, uint8_t u8IsTenMMsk, uint8_t u8IsMMsk, uint8_t u8IsTenDMsk, uint8_t u8IsDMsk);
void RTC_SetAlarmTimeMask(uint8_t u8IsTenHMsk, uint8_t u8IsHMsk, uint8_t u8IsTenMMsk, uint8_t u8IsMMsk, uint8_t u8IsTenSMsk, uint8_t u8IsSMsk);
uint32_t RTC_GetDayOfWeek(void);
void RTC_SetTickPeriod(uint32_t u32TickSelection);
void RTC_EnableInt(uint32_t u32IntFlagMask);
void RTC_DisableInt(uint32_t u32IntFlagMask);

   

   

   







#line 665 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 1 "..\\..\\Library\\StdDriver\\inc\\kpi.h"
 





 











 



 



 






#line 82 "..\\..\\Library\\StdDriver\\inc\\kpi.h"

#line 89 "..\\..\\Library\\StdDriver\\inc\\kpi.h"
















 














 









 













 


void KPI_Open(KPI_T* kpi, uint32_t u32Row, uint32_t u32Col);
void KPI_Close(KPI_T* kpi);
void KPI_ConfigKeyScanTiming(KPI_T* kpi, uint32_t u32PreScale, uint32_t u32Debounce, uint32_t u32ScanDelay);
void KPI_Set3KeyReset(KPI_T* kpi, uint32_t u32Key1, uint32_t u32Key2, uint32_t u32Key3, uint32_t u32RstCnt);


   

   

   












#line 666 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"
#line 1 "..\\..\\Library\\StdDriver\\inc\\canfd.h"







 





#pragma anon_unions




 



 



 





 
#line 41 "..\\..\\Library\\StdDriver\\inc\\canfd.h"

 


 


 


 


 


 


 


 


 


 


 


 


 














 



 
typedef enum
{
    eCANFD_BYTE8  = 0,  
    eCANFD_BYTE12 = 1,  
    eCANFD_BYTE16 = 2,  
    eCANFD_BYTE20 = 3,  
    eCANFD_BYTE24 = 4,  
    eCANFD_BYTE32 = 5,  
    eCANFD_BYTE48 = 6,  
    eCANFD_BYTE64 = 7   
} E_CANFD_DATA_FIELD_SIZE;

 
typedef enum
{
    eCANFD_QUEUE_MODE = 0,  
    eCANFD_FIFO_MODE = 1    
} E_CANFD_MODE;

 
typedef struct
{
    E_CANFD_DATA_FIELD_SIZE eDataFieldSize;      
    E_CANFD_MODE            eModeSel;            
    uint32_t                u32ElemCnt;          
    uint32_t                u32DBufNumber;       
} CANFD_TX_BUF_CONFIG_T;


 
typedef struct
{
    uint32_t u32BitRate;           
    uint16_t u16TDCOffset;         
    uint16_t u16TDCFltrWin;        
    uint8_t  u8TDC;                
} CANFD_NBT_CONFIG_T;


 
typedef struct
{
    uint32_t u32BitRate;           
    uint16_t u16TDCOffset;         
    uint16_t u16TDCFltrWin;        
    uint8_t  u8TDC;                
} CANFD_DBT_CONFIG_T;

 
typedef struct
{
    uint8_t  u8PreDivider;         
    uint16_t u16NominalPrescaler;  
    uint8_t  u8NominalRJumpwidth;  
    uint8_t  u8NominalPhaseSeg1;   
    uint8_t  u8NominalPhaseSeg2;   
    uint8_t  u8NominalPropSeg;     
    uint8_t  u8DataPrescaler;      
    uint8_t  u8DataRJumpwidth;     
    uint8_t  u8DataPhaseSeg1;      
    uint8_t  u8DataPhaseSeg2;      
    uint8_t  u8DataPropSeg;        

} CANFD_TIMEING_CONFIG_T;

 
typedef struct
{
    CANFD_NBT_CONFIG_T sNormBitRate;        
    CANFD_DBT_CONFIG_T sDataBitRate;        
    CANFD_TIMEING_CONFIG_T sConfigBitTing;  
    uint8_t bFDEn;                          
    uint8_t bBitRateSwitch;                 
    uint8_t bEnableLoopBack;                
} CANFD_FD_BT_CONFIG_T;

 
typedef struct
{
    uint32_t u32SIDFC_FLSSA;  
    uint32_t u32XIDFC_FLESA;  
    uint32_t u32RXF0C_F0SA;   
    uint32_t u32RXF1C_F1SA;   
    uint32_t u32RXBC_RBSA;    
    uint32_t u32TXEFC_EFSA;   
    uint32_t u32TXBC_TBSA;    
} CANFD_RAM_PART_T;

 
typedef struct
{
    uint32_t  u32SIDFC;           
    uint32_t  u32XIDFC;           
    uint32_t  u32RxFifo0;         
    uint32_t  u32RxFifo1;         
    uint32_t  u32RxBuf;           
    uint32_t  u32TxBuf;           
    uint32_t  u32TxEventFifo;     
} CANFD_ELEM_SIZE_T;

 
typedef struct
{
    CANFD_FD_BT_CONFIG_T    sBtConfig;         
    CANFD_RAM_PART_T        sMRamStartAddr;    
    CANFD_ELEM_SIZE_T       sElemSize;         
    CANFD_TX_BUF_CONFIG_T   sTxConfig;         
    uint32_t                u32MRamSize;       
} CANFD_FD_T;

 
typedef enum
{
    eCANFD_SID = 0,   
    eCANFD_XID = 1    
} E_CANFD_ID_TYPE;

 
typedef enum
{
    eCANFD_RX_FIFO_0 = 0,
    eCANFD_RX_FIFO_1 = 1,
    eCANFD_RX_DBUF = 2
} E_CANFD_RX_BUF_TYPE;

 
typedef enum
{
    eCANFD_SYNC         = 0,
    eCANFD_IDLE         = 1,
    eCANFD_RECEIVER     = 2,
    eCANFD_TRANSMITTER  = 3
} E_CANFD_COMMUNICATION_STATE;


 
typedef enum
{
    eCANFD_TRANSMIT_FAIL     = 0,
    eCANFD_TRANSMIT_SUCCESS  = 1,
    eCANFD_TRANSMIT_TIMEOUT  = 2
} E_CANFD_TRANSMIT_STATE;

 
typedef enum
{
    eCANFD_RECEIVE_EMPTY     = 0,
    eCANFD_RECEIVE_SUCCESS   = 1,
    eCANFD_RECEIVE_SUCCESS_AND_BUFFER_FULL   = 2

} E_CANFD_RECEIVE_STATE;

 
typedef struct
{
    E_CANFD_RX_BUF_TYPE  eRxBuf;          
    uint32_t            u32BufIdx;        
} CANFD_RX_INFO_T;

 
typedef enum
{
    eCANFD_DATA_FRM = 0,       
    eCANFD_REMOTE_FRM = 1      
} E_CANFD_FRM_TYPE;

 
typedef struct
{
    E_CANFD_ID_TYPE   eIdType;                          
    CANFD_RX_INFO_T   sRxInfo;                          
    E_CANFD_FRM_TYPE  eFrmType;                         
    uint32_t          u32Id;                            
    uint32_t          u32DLC;                           
    union
    {
        uint32_t au32Data[64/4];     
        uint8_t  au8Data[64];      
    };
    uint8_t           u8MsgMarker;                      
    uint8_t           bFDFormat;                        
    uint8_t           bBitRateSwitch;                   
    uint8_t           bErrStaInd;                       
    uint8_t           bEvntFifoCon;                     
} CANFD_FD_MSG_T;


 
typedef struct
{
    uint32_t u32Id;      
    uint32_t u32Config;  
    union
    {
        uint32_t au32Data[64/4];   
        uint8_t  au8Data[64];    
    };
} CANFD_BUF_T;

 
typedef struct
{
    union
    {
        struct
        {
            uint32_t SFID2     : 11;  
            uint32_t reserved1 : 5;
            uint32_t SFID1     : 11;  
            uint32_t SFEC      : 3;   
            uint32_t SFT       : 2;   
        };
        struct
        {
            uint32_t VALUE;  
        };
    };
} CANFD_STD_FILTER_T;

 
typedef struct
{
    union
    {
        struct
        {
            uint32_t EFID1     : 29;  
            uint32_t EFEC      : 3;   
            uint32_t EFID2     : 29;  
            uint32_t reserved1 : 1;
            uint32_t EFT       : 2;   
        };
        struct
        {
            uint32_t LOWVALUE;   
            uint32_t HIGHVALUE;  
        };
    };
} CANFD_EXT_FILTER_T;

 
typedef enum
{
    eCANFD_ACC_NON_MATCH_FRM_RX_FIFO0 = 0x0,   
    eCANFD_ACC_NON_MATCH_FRM_RX_FIFO1 = 0x1,   
    eCANFD_REJ_NON_MATCH_FRM   = 0x3           
} E_CANFD_ACC_NON_MATCH_FRM;


 
typedef enum
{
    eCANFD_SID_FLTR_TYPE_RANGE     = 0x0,  
    eCANFD_SID_FLTR_TYPE_DUAL      = 0x1,  
    eCANFD_SID_FLTR_TYPE_CLASSIC   = 0x2,  
    eCANFD_SID_FLTR_TYPE_DIS       = 0x3   
} E_CANFD_SID_FLTR_ELEM_TYPE;

 
typedef enum
{
    eCANFD_XID_FLTR_TYPE_RANGE      = 0x0,   
    eCANFD_XID_FLTR_TYPE_DUAL       = 0x1,   
    eCANFD_XID_FLTR_TYPE_CLASSIC    = 0x2,   
    eCANFD_XID_FLTR_TYPE_RANGE_XIDAM_NOT_APP     = 0x3    
}  E_CANFD_XID_FLTR_ELEM_TYPE;

 
typedef enum
{
    eCANFD_FLTR_ELEM_DIS         = 0x0,             
    eCANFD_FLTR_ELEM_STO_FIFO0   = 0x1,             
    eCANFD_FLTR_ELEM_STO_FIFO1   = 0x2,             
    eCANFD_FLTR_ELEM_REJ_ID      = 0x3,             
    eCANFD_FLTR_ELEM_SET_PRI     = 0x4,             
    eCANFD_FLTR_ELEM_SET_PRI_STO_FIFO0 = 0x5,       
    eCANFD_FLTR_ELEM_SET_PRI_STO_FIFO1 = 0x6,       
    eCANFD_FLTR_ELEM_STO_RX_BUF_OR_DBG_MSG = 0x7    
} E_CANFD_FLTR_CONFIG;

 
typedef struct
{
    E_CANFD_ID_TYPE     eIdType;          
    uint32_t            u32Id;            
    uint32_t            u32DLC;           
    uint32_t            u32TxTs;          
    uint32_t            u32MsgMarker;     
    uint8_t             bErrStaInd;       
    uint8_t             bRemote;          
    uint8_t             bFDFormat;        
    uint8_t             bBitRateSwitch;   
} CANFD_TX_EVNT_ELEM_T;



static __inline uint32_t CANFD_ReadReg(uint32_t u32RegAddr);

static __inline uint32_t CANFD_ReadReg(uint32_t u32RegAddr)
{
    uint32_t u32ReadReg;
    uint32_t u32TimeOutCnt = 48;
    u32ReadReg = 0UL;

    do{
        u32ReadReg = (*((volatile unsigned int *)((uint32_t *)u32RegAddr)));
        if(--u32TimeOutCnt == 0UL)
        {
            break;
        }
      }while(u32ReadReg == 0UL);

    return u32ReadReg;
}

void CANFD_Open(CANFD_T *canfd, CANFD_FD_T *psCanfdStr);
void CANFD_Close(CANFD_T *canfd);
void CANFD_EnableInt(CANFD_T *canfd, uint32_t u32IntLine0, uint32_t u32IntLine1, uint32_t u32TXBTIE, uint32_t u32TXBCIE);
void CANFD_DisableInt(CANFD_T *canfd, uint32_t u32IntLine0, uint32_t u32IntLine1, uint32_t u32TXBTIE, uint32_t u32TXBCIE);
uint32_t CANFD_TransmitTxMsg(CANFD_T *canfd, uint32_t u32TxBufIdx, CANFD_FD_MSG_T *psTxMsg);
uint32_t CANFD_TransmitDMsg(CANFD_T *canfd, uint32_t u32TxBufIdx, CANFD_FD_MSG_T *psTxMsg);
void CANFD_SetGFC(CANFD_T *canfd, E_CANFD_ACC_NON_MATCH_FRM eNMStdFrm, E_CANFD_ACC_NON_MATCH_FRM eEMExtFrm, uint32_t u32RejRmtStdFrm, uint32_t u32RejRmtExtFrm);
void CANFD_InitRxFifo(CANFD_T *canfd, uint32_t u32RxFifoNum, CANFD_RAM_PART_T *psRamConfig, CANFD_ELEM_SIZE_T *psElemSize, uint32_t u32FifoWM, E_CANFD_DATA_FIELD_SIZE eFifoSize);
void CANFD_InitRxDBuf(CANFD_T *canfd, CANFD_RAM_PART_T *psRamConfig, CANFD_ELEM_SIZE_T *psElemSize, E_CANFD_DATA_FIELD_SIZE eRxBufSize);
void CANFD_InitTxDBuf(CANFD_T *canfd, CANFD_RAM_PART_T *psRamConfig, CANFD_ELEM_SIZE_T *psElemSize, E_CANFD_DATA_FIELD_SIZE eTxBufSize);
void CANFD_InitTxEvntFifo(CANFD_T *canfd, CANFD_RAM_PART_T *psRamConfig, CANFD_ELEM_SIZE_T *psElemSize, uint32_t u32FifoWaterLvl);
void CANFD_ConfigSIDFC(CANFD_T *canfd, CANFD_RAM_PART_T *psRamConfig, CANFD_ELEM_SIZE_T *psElemSize);
void CANFD_ConfigXIDFC(CANFD_T *canfd, CANFD_RAM_PART_T *psRamConfig, CANFD_ELEM_SIZE_T *psElemSize);
void CANFD_SetSIDFltr(CANFD_T *canfd, uint32_t u32FltrIdx, uint32_t u32Filter);
void CANFD_SetXIDFltr(CANFD_T *canfd, uint32_t u32FltrIdx, uint32_t u32FilterLow, uint32_t u32FilterHigh);
uint32_t CANFD_ReadRxBufMsg(CANFD_T *canfd, uint8_t u8MbIdx, CANFD_FD_MSG_T *psMsgBuf);
uint32_t CANFD_ReadRxFifoMsg(CANFD_T *canfd, uint8_t u8FifoIdx, CANFD_FD_MSG_T *psMsgBuf);
void CANFD_CopyDBufToMsgBuf(CANFD_BUF_T *psRxBuffer, CANFD_FD_MSG_T *psMsgBuf);
void CANFD_CopyRxFifoToMsgBuf(CANFD_BUF_T *psRxBuf, CANFD_FD_MSG_T *psMsgBuf);
uint32_t CANFD_GetRxFifoWaterLvl(CANFD_T *canfd, uint32_t u32RxFifoNum);
void CANFD_TxBufCancelReq(CANFD_T *canfd, uint32_t u32TxBufIdx);
uint32_t CANFD_IsTxBufCancelFin(CANFD_T *canfd, uint32_t u32TxBufIdx);
uint32_t CANFD_IsTxBufTransmitOccur(CANFD_T *canfd, uint32_t u32TxBufIdx);
uint32_t CANFD_GetTxEvntFifoWaterLvl(CANFD_T *canfd);
void CANFD_CopyTxEvntFifoToUsrBuf(CANFD_T *canfd, uint32_t u32TxEvntNum, CANFD_TX_EVNT_ELEM_T *psTxEvntElem);
void CANFD_GetBusErrCount(CANFD_T *canfd, uint8_t *pu8TxErrBuf, uint8_t *pu8RxErrBuf);
void CANFD_RunToNormal(CANFD_T *canfd, uint8_t u8Enable);
void CANFD_GetDefaultConfig(CANFD_FD_T *psConfig, uint8_t u8OpMode);
void CANFD_ClearStatusFlag(CANFD_T *canfd, uint32_t u32InterruptFlag);
uint32_t CANFD_GetStatusFlag(CANFD_T *canfd, uint32_t u32IntTypeFlag);

   

   

   


#pragma no_anon_unions


#line 667 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\ma35d1_rtp.h"







#line 12 "..\\..\\Library\\Device\\Nuvoton\\ma35d1_rtp\\Include\\NuMicro.h"




#line 9 "..\\..\\Library\\StdDriver\\src\\wwdt.c"




 



 



 




























 
void WWDT_Open(uint32_t u32PreScale,
               uint32_t u32CmpValue,
               uint32_t u32EnableInt)
{
    ((WWDT_T *) (0x40980100UL))->CTL = u32PreScale |
                (u32CmpValue << (16)) |
                ((u32EnableInt == (1UL)) ? (0x1ul << (1)) : 0U) |
                (0x1ul << (0));
    return;
}

   

   

   

